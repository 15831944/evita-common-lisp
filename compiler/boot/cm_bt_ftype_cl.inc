// This file is automatically generated at:
//  2006-11-30 00:02:03
//
// DO NOT EDIT THIS FILE!
//
  // documentation (function (t symbol) (or string null))
  add_ftype(Q("DOCUMENTATION"),
    list(t, Qsymbol),
    list(Q("OR"), Qstring, Qnull) );

  // (setf documentation) (function ((or string null) t symbol) (or string null))
  add_ftype(intern_setf_cell(Q("DOCUMENTATION")),
    list(list(Q("OR"), Qstring, Qnull), t, Qsymbol),
    list(Q("OR"), Qstring, Qnull) );

  // update-instance-for-redefined-class (function (t list list list &key &allow-other-keys) t)
  add_ftype(Q("UPDATE-INSTANCE-FOR-REDEFINED-CLASS"),
    list(t, Qlist, Qlist, Qlist, Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // string-upcase (function (string &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("STRING-UPCASE"),
    list(Q("STRING-DESIGNATOR"), Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // tenth (function (list) t)
  add_ftype(Q("TENTH"),
    list(Qlist),
    t );

  // (setf tenth) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("TENTH")),
    list(t, Qcons),
    t );

  // room (function (&optional (member nil t :default)) t)
  add_ftype(Q("ROOM"),
    list(Q("&OPTIONAL"), list(Q("MEMBER"), nil, t, Q(":DEFAULT"))),
    t );

  // mapc (function (function-designator list &rest list) list)
  add_ftype(Q("MAPC"),
    list(Q("FUNCTION-DESIGNATOR"), Qlist, Q("&REST"), Qlist),
    Qlist );

  // keywordp (function (t) t)
  add_ftype(Q("KEYWORDP"),
    list(t),
    t );

  // lower-case-p (function (character) t)
  add_ftype(Q("LOWER-CASE-P"),
    list(Qcharacter),
    t );

  // decode-float (function (float) (values float integer float))
  add_ftype(Q("DECODE-FLOAT"),
    list(Qfloat),
    list(Q("VALUES"), Qfloat, Qinteger, Qfloat) );

  // acosh (function (number) number)
  add_ftype(Q("ACOSH"),
    list(Qnumber),
    Qnumber );

  // bit-nand (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-NAND"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // array-element-type (function (array) type-specifier)
  add_ftype(Q("ARRAY-ELEMENT-TYPE"),
    list(Qarray),
    Q("TYPE-SPECIFIER") );

  // host-namestring (function (pathname-designator) string)
  add_ftype(Q("HOST-NAMESTRING"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qstring );

  // user-homedir-pathname (function (&optional (or string list (eql :unspecific))) (or pathname null))
  add_ftype(Q("USER-HOMEDIR-PATHNAME"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qstring, Qlist, list(Q("EQL"), Q(":UNSPECIFIC")))),
    list(Q("OR"), Qpathname, Qnull) );

  // log (function (number &optional number) number)
  add_ftype(Q("LOG"),
    list(Qnumber, Q("&OPTIONAL"), Qnumber),
    Qnumber );

  // logand (function (&rest integer) integer)
  add_ftype(Q("LOGAND"),
    list(Q("&REST"), Qinteger),
    Qinteger );

  // subseq (function (sequence sequence-index &optional sequence-end) t)
  add_ftype(Q("SUBSEQ"),
    list(Qsequence, Q("SEQUENCE-INDEX"), Q("&OPTIONAL"), Q("SEQUENCE-END")),
    t );

  // reinitialize-instance (function (t &key &allow-other-keys) t)
  add_ftype(Q("REINITIALIZE-INSTANCE"),
    list(t, Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // rationalp (function (t) t)
  add_ftype(Q("RATIONALP"),
    list(t),
    t );

  // < (function (real &rest real) t)
  add_ftype(Q("<"),
    list(Qreal, Q("&REST"), Qreal),
    t );

  // acos (function (number) number)
  add_ftype(Q("ACOS"),
    list(Qnumber),
    Qnumber );

  // class-name (function (class) symbol)
  add_ftype(Q("CLASS-NAME"),
    list(Qclass),
    Qsymbol );

  // (setf class-name) (function (symbol class) symbol)
  add_ftype(intern_setf_cell(Q("CLASS-NAME")),
    list(Qsymbol, Qclass),
    Qsymbol );

  // make-two-way-stream (function (stream stream) two-way-stream)
  add_ftype(Q("MAKE-TWO-WAY-STREAM"),
    list(Qstream, Qstream),
    Qtwo_way_stream );

  // shared-initialize (function (t (or list (eql t)) &key &allow-other-keys) t)
  add_ftype(Q("SHARED-INITIALIZE"),
    list(t, list(Q("OR"), Qlist, list(Q("EQL"), t)), Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // nconc (function (&rest t) list)
  add_ftype(Q("NCONC"),
    list(Q("&REST"), t),
    Qlist );

  // bit-andc2 (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-ANDC2"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // caaar (function (list) t)
  add_ftype(Q("CAAAR"),
    list(Qlist),
    t );

  // (setf caaar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAAAR")),
    list(t, Qcons),
    t );

  // cadar (function (list) t)
  add_ftype(Q("CADAR"),
    list(Qlist),
    t );

  // (setf cadar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CADAR")),
    list(t, Qcons),
    t );

  // make-instance (function (class-designator &key &allow-other-keys) t)
  add_ftype(Q("MAKE-INSTANCE"),
    list(Q("CLASS-DESIGNATOR"), Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // mapl (function (function-designator list &rest list) list)
  add_ftype(Q("MAPL"),
    list(Q("FUNCTION-DESIGNATOR"), Qlist, Q("&REST"), Qlist),
    Qlist );

  // array-dimensions (function (array) list)
  add_ftype(Q("ARRAY-DIMENSIONS"),
    list(Qarray),
    Qlist );

  // fresh-line (function (&optional (or stream (member nil t))) t)
  add_ftype(Q("FRESH-LINE"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t))),
    t );

  // nth (function (sequence-index list) t)
  add_ftype(Q("NTH"),
    list(Q("SEQUENCE-INDEX"), Qlist),
    t );

  // (setf nth) (function (t sequence-index list) t)
  add_ftype(intern_setf_cell(Q("NTH")),
    list(t, Q("SEQUENCE-INDEX"), Qlist),
    t );

  // rename-file (function (pathname-designator pathname-designator) (values pathname physical-pathname physical-pathname))
  add_ftype(Q("RENAME-FILE"),
    list(Q("PATHNAME-DESIGNATOR"), Q("PATHNAME-DESIGNATOR")),
    list(Q("VALUES"), Qpathname, Qphysical_pathname, Qphysical_pathname) );

  // slot-value (function (t symbol) t)
  add_ftype(Q("SLOT-VALUE"),
    list(t, Qsymbol),
    t );

  // (setf slot-value) (function (t t symbol) t)
  add_ftype(intern_setf_cell(Q("SLOT-VALUE")),
    list(t, t, Qsymbol),
    t );

  // acons (function (t t list) list)
  add_ftype(Q("ACONS"),
    list(t, t, Qlist),
    Qlist );

  // lcm (function (&rest integer) integer)
  add_ftype(Q("LCM"),
    list(Q("&REST"), Qinteger),
    Qinteger );

  // mismatch (function (sequence sequence &key (:key key-function) (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end) (:from-end t) (:test test-2-function) (:test-no test-2-function)) (or sequence-index null))
  add_ftype(Q("MISMATCH"),
    cons(Qsequence, cons(Qsequence, cons(Q("&KEY"), cons(list(Q(":KEY"), Q("KEY-FUNCTION")), cons(list(Q(":START1"), Q("SEQUENCE-INDEX")), list(list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NO"), Q("TEST-2-FUNCTION")))))))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // upper-case-p (function (character) t)
  add_ftype(Q("UPPER-CASE-P"),
    list(Qcharacter),
    t );

  // logbitp (function (unsigned-byte integer) t)
  add_ftype(Q("LOGBITP"),
    list(Q("UNSIGNED-BYTE"), Qinteger),
    t );

  // find (function (t sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function) (:test test-2-function) (:test-not test-2-function)) t)
  add_ftype(Q("FIND"),
    cons(t, cons(Qsequence, cons(Q("&KEY"), list(list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION")))))),
    t );

  // bit-orc2 (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-ORC2"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // adjoin (function (t list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("ADJOIN"),
    list(t, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // copy-pprint-dispatch (function (&optional (or pp-dispatch-table null)) pp-dispatch-table)
  add_ftype(Q("COPY-PPRINT-DISPATCH"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qpp_dispatch_table, Qnull)),
    Qpp_dispatch_table );

  // logical-pathname (function ((or logical-pathname string stream)) logical-pathname)
  add_ftype(Qlogical_pathname,
    list(list(Q("OR"), Qlogical_pathname, Qstring, Qstream)),
    Qlogical_pathname );

  // boundp (function (symbol) t)
  add_ftype(Q("BOUNDP"),
    list(Qsymbol),
    t );

  // count-if (function (test-1-function sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) sequence-index)
  add_ftype(Q("COUNT-IF"),
    cons(Q("TEST-1-FUNCTION"), list(Qsequence, Q("&KEY"), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")))),
    Q("SEQUENCE-INDEX") );

  // merge-pathnames (function (pathname-designator &optional pathname-designator (or unsigned-byte null (member :wil :newest :unspecific))) pathname)
  add_ftype(Q("MERGE-PATHNAMES"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&OPTIONAL"), Q("PATHNAME-DESIGNATOR"), list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull, list(Q("MEMBER"), Q(":WIL"), Q(":NEWEST"), Q(":UNSPECIFIC")))),
    Qpathname );

  // echo-stream-output-stream (function (echo-stream) stream)
  add_ftype(Q("ECHO-STREAM-OUTPUT-STREAM"),
    list(Qecho_stream),
    Qstream );

  // pprint-linear (function (stream t &optional t t) (values null))
  add_ftype(Q("PPRINT-LINEAR"),
    list(Qstream, t, Q("&OPTIONAL"), t, t),
    list(Q("VALUES"), Qnull) );

  // slot-unbound (function (class t symbol) t)
  add_ftype(Q("SLOT-UNBOUND"),
    list(Qclass, t, Qsymbol),
    t );

  // characterp (function (t) t)
  add_ftype(Q("CHARACTERP"),
    list(t),
    t );

  // substitute (function (t t sequence &key (:start sequence-index) (:end sequence-end) (:from-end t) (:key key-function) (:count sequence-end) (:test test-2-function) (:test-not test-2-function)) sequence)
  add_ftype(Q("SUBSTITUTE"),
    cons(t, cons(t, cons(Qsequence, cons(Q("&KEY"), cons(list(Q(":START"), Q("SEQUENCE-INDEX")), list(list(Q(":END"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":COUNT"), Q("SEQUENCE-END")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION")))))))),
    Qsequence );

  // svref (function (simple-vector sequence-index) t)
  add_ftype(Q("SVREF"),
    list(Qsimple_vector, Q("SEQUENCE-INDEX")),
    t );

  // (setf svref) (function (t simple-vector sequence-index) t)
  add_ftype(intern_setf_cell(Q("SVREF")),
    list(t, Qsimple_vector, Q("SEQUENCE-INDEX")),
    t );

  // synonym-stream-symbol (function (synonym-stream) symbol)
  add_ftype(Q("SYNONYM-STREAM-SYMBOL"),
    list(Qsynonym_stream),
    Qsymbol );

  // tan (function (number) number)
  add_ftype(Q("TAN"),
    list(Qnumber),
    Qnumber );

  // nreconc (function (list t) t)
  add_ftype(Q("NRECONC"),
    list(Qlist, t),
    t );

  // ldiff (function (list t) list)
  add_ftype(Q("LDIFF"),
    list(Qlist, t),
    Qlist );

  // vector-pop (function (vector) t)
  add_ftype(Q("VECTOR-POP"),
    list(Qvector),
    t );

  // hash-table-size (function (hash-table) sequence-index)
  add_ftype(Q("HASH-TABLE-SIZE"),
    list(Qhash_table),
    Q("SEQUENCE-INDEX") );

  // parse-integer (function (string &key (:start sequence-index) (:end sequence-end) (:radix (integer 2 36)) (:junk-allowed t)) (values (or integer null) sequence-index))
  add_ftype(Q("PARSE-INTEGER"),
    list(Qstring, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":RADIX"), list(Qinteger, Fixnum::Encode(2), Fixnum::Encode(36))), list(Q(":JUNK-ALLOWED"), t)),
    list(Q("VALUES"), list(Q("OR"), Qinteger, Qnull), Q("SEQUENCE-INDEX")) );

  // / (function (number &rest number) number)
  add_ftype(Q("/"),
    list(Qnumber, Q("&REST"), Qnumber),
    Qnumber );

  // string-not-greaterp (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING-NOT-GREATERP"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // string (function ((or string symbol character)) string)
  add_ftype(Qstring,
    list(list(Q("OR"), Qstring, Qsymbol, Qcharacter)),
    Qstring );

  // char-downcase (function (character) character)
  add_ftype(Q("CHAR-DOWNCASE"),
    list(Qcharacter),
    Qcharacter );

  // use-package (function ((or package-designator list) &optional package-designator) (eql t))
  add_ftype(Q("USE-PACKAGE"),
    list(list(Q("OR"), Q("PACKAGE-DESIGNATOR"), Qlist), Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // tree-equal (function (list list &key (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("TREE-EQUAL"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // nthcdr (function (sequence-index list) t)
  add_ftype(Q("NTHCDR"),
    list(Q("SEQUENCE-INDEX"), Qlist),
    t );

  // software-version (function nil simple-string)
  add_ftype(Q("SOFTWARE-VERSION"),
    nil,
    Qsimple_string );

  // pathname-device (function (pathname &key (:case (member :local :common))) (or string null (eql :unspecific)))
  add_ftype(Q("PATHNAME-DEVICE"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":CASE"), list(Q("MEMBER"), Q(":LOCAL"), Q(":COMMON")))),
    list(Q("OR"), Qstring, Qnull, list(Q("EQL"), Q(":UNSPECIFIC"))) );

  // ninth (function (list) t)
  add_ftype(Q("NINTH"),
    list(Qlist),
    t );

  // (setf ninth) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("NINTH")),
    list(t, Qcons),
    t );

  // delete (function (t sequence &key (:count (or integer null)) (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function) (:test test-2-function) (:test-not test-2-function)) sequence)
  add_ftype(Q("DELETE"),
    cons(t, cons(Qsequence, cons(Q("&KEY"), cons(list(Q(":COUNT"), list(Q("OR"), Qinteger, Qnull)), list(list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))))))),
    Qsequence );

  // invoke-restart-interactively (function (restart-designator) (values &rest t))
  add_ftype(Q("INVOKE-RESTART-INTERACTIVELY"),
    list(Q("RESTART-DESIGNATOR")),
    list(Q("VALUES"), Q("&REST"), t) );

  // rationalize (function (real) rational)
  add_ftype(Q("RATIONALIZE"),
    list(Qreal),
    Qrational );

  // vectorp (function (t) t)
  add_ftype(Q("VECTORP"),
    list(t),
    t );

  // find-method (function (generic-function list list &optional t) (or method null))
  add_ftype(Q("FIND-METHOD"),
    list(Qgeneric_function, Qlist, Qlist, Q("&OPTIONAL"), t),
    list(Q("OR"), Qmethod, Qnull) );

  // proclaim (function (list) t)
  add_ftype(Q("PROCLAIM"),
    list(Qlist),
    t );

  // rplacd (function (cons t) cons)
  add_ftype(Q("RPLACD"),
    list(Qcons, t),
    Qcons );

  // sort (function (sequence test-2-function &key (:key key-function)) sequence)
  add_ftype(Q("SORT"),
    list(Qsequence, Q("TEST-2-FUNCTION"), Q("&KEY"), list(Q(":KEY"), Q("KEY-FUNCTION"))),
    Qsequence );

  // sqrt (function (number) number)
  add_ftype(Q("SQRT"),
    list(Qnumber),
    Qnumber );

  // remove (function (t sequence &key (:count (or integer null)) (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function) (:test test-2-function) (:test-not test-2-function)) sequence)
  add_ftype(Q("REMOVE"),
    cons(t, cons(Qsequence, cons(Q("&KEY"), cons(list(Q(":COUNT"), list(Q("OR"), Qinteger, Qnull)), list(list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))))))),
    Qsequence );

  // two-way-stream-input-stream (function (two-way-stream) stream)
  add_ftype(Q("TWO-WAY-STREAM-INPUT-STREAM"),
    list(Qtwo_way_stream),
    Qstream );

  // initialize-instance (function (t &key &allow-other-keys) t)
  add_ftype(Q("INITIALIZE-INSTANCE"),
    list(t, Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // pprint (function (t &optional stream-designator) (values))
  add_ftype(Q("PPRINT"),
    list(t, Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    list(Q("VALUES")) );

  // fceiling (function (real &optional real) (values float real))
  add_ftype(Q("FCEILING"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qfloat, Qreal) );

  // fill (function (sequence t &key (:start sequence-index) (:end sequence-end)) sequence)
  add_ftype(Q("FILL"),
    list(Qsequence, t, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qsequence );

  // macroexpand (function (t &optional t) (values t t))
  add_ftype(Q("MACROEXPAND"),
    list(t, Q("&OPTIONAL"), t),
    list(Q("VALUES"), t, t) );

  // invalid-method-error (function (method format-control &rest t) t)
  add_ftype(Q("INVALID-METHOD-ERROR"),
    list(Qmethod, Q("FORMAT-CONTROL"), Q("&REST"), t),
    t );

  // machine-instance (function nil simple-string)
  add_ftype(Q("MACHINE-INSTANCE"),
    nil,
    Qsimple_string );

  // find-restart (function ((or symbol (not null) restart) &optional (or condition null)) (or restart null))
  add_ftype(Q("FIND-RESTART"),
    list(list(Q("OR"), Qsymbol, list(Q("NOT"), Qnull), Qrestart), Q("&OPTIONAL"), list(Q("OR"), Qcondition, Qnull)),
    list(Q("OR"), Qrestart, Qnull) );

  // position (function (t sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function) (:test test-2-function) (:test-not test-2-function)) (or sequence-index null))
  add_ftype(Q("POSITION"),
    cons(t, cons(Qsequence, cons(Q("&KEY"), list(list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION")))))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // file-length (function (stream) (or unsigned-byte null))
  add_ftype(Q("FILE-LENGTH"),
    list(Qstream),
    list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull) );

  // package-use-list (function (package-designator) list)
  add_ftype(Q("PACKAGE-USE-LIST"),
    list(Q("PACKAGE-DESIGNATOR")),
    Qlist );

  // char-name (function (character) (or string null))
  add_ftype(Q("CHAR-NAME"),
    list(Qcharacter),
    list(Q("OR"), Qstring, Qnull) );

  // set-pprint-dispatch (function (type-specifier (or function symbol) &optional real pp-dispatch-table) (values null))
  add_ftype(Q("SET-PPRINT-DISPATCH"),
    list(Q("TYPE-SPECIFIER"), Q("FUNCTION-DESIGNATOR"), Q("&OPTIONAL"), Qreal, Qpp_dispatch_table),
    list(Q("VALUES"), Qnull) );

  // /= (function (number &rest number) t)
  add_ftype(Q("/="),
    list(Qnumber, Q("&REST"), Qnumber),
    t );

  // decode-universal-time (function (integer &optional time-zone) (values (integer 0 59) (integer 0 59) (integer 0 23) (integer 1 31) (integer 1 12) (integer 1 *) (integer 0 6) t (rational -24 24)))
  add_ftype(Q("DECODE-UNIVERSAL-TIME"),
    list(Qinteger, Q("&OPTIONAL"), Q("TIME-ZONE")),
    cons(Q("VALUES"), cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(59)), cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(59)), cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(23)), list(list(Qinteger, Fixnum::Encode(1), Fixnum::Encode(31)), list(Qinteger, Fixnum::Encode(1), Fixnum::Encode(12)), list(Qinteger, Fixnum::Encode(1), Q("*")), list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(6)), t, list(Qrational, Fixnum::Encode(-24), Fixnum::Encode(24))))))) );

  // both-case-p (function (character) t)
  add_ftype(Q("BOTH-CASE-P"),
    list(Qcharacter),
    t );

  // file-author (function (pathname-designator) (or string null))
  add_ftype(Q("FILE-AUTHOR"),
    list(Q("PATHNAME-DESIGNATOR")),
    list(Q("OR"), Qstring, Qnull) );

  // pprint-tabular (function (stream t &optional t t unsigned-byte) (values null))
  add_ftype(Q("PPRINT-TABULAR"),
    list(Qstream, t, Q("&OPTIONAL"), t, t, Q("UNSIGNED-BYTE")),
    list(Q("VALUES"), Qnull) );

  // nstring-downcase (function (string &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("NSTRING-DOWNCASE"),
    list(Qstring, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // rassoc-if-not (function (predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("RASSOC-IF-NOT"),
    list(Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // print (function (t &optional stream-designator) (values t))
  add_ftype(Q("PRINT"),
    list(t, Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    list(Q("VALUES"), t) );

  // atom (function (t) t)
  add_ftype(Q("ATOM"),
    list(t),
    t );

  // copy-seq (function (sequence) sequence)
  add_ftype(Q("COPY-SEQ"),
    list(Qsequence),
    Qsequence );

  // ensure-directories-exist (function (pathname-designator &key (:verbose t)) (values pathname-designator t))
  add_ftype(Q("ENSURE-DIRECTORIES-EXIST"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":VERBOSE"), t)),
    list(Q("VALUES"), Q("PATHNAME-DESIGNATOR"), t) );

  // typep (function (t type-specifier) t)
  add_ftype(Q("TYPEP"),
    list(t, Q("TYPE-SPECIFIER")),
    t );

  // lisp-implementation-type (function nil simple-string)
  add_ftype(Q("LISP-IMPLEMENTATION-TYPE"),
    nil,
    Qsimple_string );

  // funcall (function (function-designator &rest t) (values &rest t))
  add_ftype(Q("FUNCALL"),
    list(Q("FUNCTION-DESIGNATOR"), Q("&REST"), t),
    list(Q("VALUES"), Q("&REST"), t) );

  // asin (function (number) number)
  add_ftype(Q("ASIN"),
    list(Qnumber),
    Qnumber );

  // lisp-implementation-version (function nil simple-string)
  add_ftype(Q("LISP-IMPLEMENTATION-VERSION"),
    nil,
    Qsimple_string );

  // nsubst (function (t t t &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) t)
  add_ftype(Q("NSUBST"),
    cons(t, list(t, t, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION")))),
    t );

  // prin1 (function (t &optional stream-designator) (values t))
  add_ftype(Q("PRIN1"),
    list(t, Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    list(Q("VALUES"), t) );

  // make-concatenated-stream (function (&rest stream) concatenated-stream)
  add_ftype(Q("MAKE-CONCATENATED-STREAM"),
    list(Q("&REST"), Qstream),
    Qconcatenated_stream );

  // copy-alist (function (list) list)
  add_ftype(Q("COPY-ALIST"),
    list(Qlist),
    Qlist );

  // revappend (function (list t) t)
  add_ftype(Q("REVAPPEND"),
    list(Qlist, t),
    t );

  // lognor (function (integer integer) integer)
  add_ftype(Q("LOGNOR"),
    list(Qinteger, Qinteger),
    Qinteger );

  // write-byte (function (unsigned-byte stream) unsigned-byte)
  add_ftype(Q("WRITE-BYTE"),
    list(Q("UNSIGNED-BYTE"), Qstream),
    Q("UNSIGNED-BYTE") );

  // logior (function (&rest integer) integer)
  add_ftype(Q("LOGIOR"),
    list(Q("&REST"), Qinteger),
    Qinteger );

  // truename (function (pathname-designator) physical-pathname)
  add_ftype(Q("TRUENAME"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qphysical_pathname );

  // unbound-slot-instance (function (unbound-slot) t)
  add_ftype(Q("UNBOUND-SLOT-INSTANCE"),
    list(Q("UNBOUND-SLOT")),
    t );

  // cons (function (t t) cons)
  add_ftype(Qcons,
    list(t, t),
    Qcons );

  // logxor (function (&rest integer) integer)
  add_ftype(Q("LOGXOR"),
    list(Q("&REST"), Qinteger),
    Qinteger );

  // float-sign (function (float &optional float) float)
  add_ftype(Q("FLOAT-SIGN"),
    list(Qfloat, Q("&OPTIONAL"), Qfloat),
    Qfloat );

  // compute-restarts (function (&optional (or condition null)) list)
  add_ftype(Q("COMPUTE-RESTARTS"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qcondition, Qnull)),
    Qlist );

  // make-string-input-stream (function (string &optional sequence-index sequence-end) string-input-stream)
  add_ftype(Q("MAKE-STRING-INPUT-STREAM"),
    list(Qstring, Q("&OPTIONAL"), Q("SEQUENCE-INDEX"), Q("SEQUENCE-END")),
    Qstring_input_stream );

  // cadadr (function (list) t)
  add_ftype(Q("CADADR"),
    list(Qlist),
    t );

  // (setf cadadr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CADADR")),
    list(t, Qcons),
    t );

  // cddaar (function (list) t)
  add_ftype(Q("CDDAAR"),
    list(Qlist),
    t );

  // (setf cddaar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDDAAR")),
    list(t, Qcons),
    t );

  // cadddr (function (list) t)
  add_ftype(Q("CADDDR"),
    list(Qlist),
    t );

  // (setf cadddr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CADDDR")),
    list(t, Qcons),
    t );

  // cdddar (function (list) t)
  add_ftype(Q("CDDDAR"),
    list(Qlist),
    t );

  // (setf cdddar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDDDAR")),
    list(t, Qcons),
    t );

  // standard-char-p (function (character) t)
  add_ftype(Q("STANDARD-CHAR-P"),
    list(Qcharacter),
    t );

  // software-type (function nil simple-string)
  add_ftype(Q("SOFTWARE-TYPE"),
    nil,
    Qsimple_string );

  // symbol-name (function (symbol) string)
  add_ftype(Q("SYMBOL-NAME"),
    list(Qsymbol),
    Qsimple_string );

  // subst (function (t t t &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) t)
  add_ftype(Q("SUBST"),
    cons(t, list(t, t, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION")))),
    t );

  // array-in-bounds-p (function (array &rest sequence-index) t)
  add_ftype(Q("ARRAY-IN-BOUNDS-P"),
    list(Qarray, Q("&REST"), Q("SEQUENCE-INDEX")),
    t );

  // = (function (number &rest number) t)
  add_ftype(Q("="),
    list(Qnumber, Q("&REST"), Qnumber),
    t );

  // endp (function (t) t)
  add_ftype(Q("ENDP"),
    list(t),
    t );

  // char<= (function (&rest character) t)
  add_ftype(Q("CHAR<="),
    list(Q("&REST"), Qcharacter),
    t );

  // copy-tree (function (t) t)
  add_ftype(Q("COPY-TREE"),
    list(t),
    t );

  // hash-table-test (function (hash-table) (member eq eql equal equalp))
  add_ftype(Q("HASH-TABLE-TEST"),
    list(Qhash_table),
    list(Q("MEMBER"), Q("EQ"), Q("EQL"), Q("EQUAL"), Q("EQUALP")) );

  // invoke-restart (function (restart-designator &rest t) (values &rest t))
  add_ftype(Q("INVOKE-RESTART"),
    list(Q("RESTART-DESIGNATOR"), Q("&REST"), t),
    list(Q("VALUES"), Q("&REST"), t) );

  // stringp (function (t) t)
  add_ftype(Q("STRINGP"),
    list(t),
    t );

  // rem (function (real real) real)
  add_ftype(Q("REM"),
    list(Qreal, Qreal),
    Qreal );

  // conjugate (function (number) number)
  add_ftype(Q("CONJUGATE"),
    list(Qnumber),
    Qnumber );

  // peek-char (function (&optional (or character (member nil t)) (or stream (member nil t)) t t t) t)
  add_ftype(Q("PEEK-CHAR"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qcharacter, list(Q("MEMBER"), nil, t)), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t)), t, t, t),
    t );

  // pairlis (function (list list &optional list) list)
  add_ftype(Q("PAIRLIS"),
    list(Qlist, Qlist, Q("&OPTIONAL"), Qlist),
    Qlist );

  // pprint-newline (function ((member :linear :fill :miser :mandatory) &optional stream) (values null))
  add_ftype(Q("PPRINT-NEWLINE"),
    list(list(Q("MEMBER"), Q(":LINEAR"), Q(":FILL"), Q(":MISER"), Q(":MANDATORY")), Q("&OPTIONAL"), Qstream),
    list(Q("VALUES"), Qnull) );

  // append (function (&rest t) t)
  add_ftype(Q("APPEND"),
    list(Q("&REST"), t),
    t );

  // make-pathname (function (&key (:case (member :common :local)) (:host (or string list (eql :unspecific))) (:device (or string null (eql :unspecific))) (:directory (or string list null (member :wild :wild-inferior :unspecific))) (:name (or string null (member :wild :unspecific))) (:type (or string null (member :wild :unspecific))) (:version (or unsigned-byte null (member :wild :newest :unspecific))) (:defaults pathname-designator)) pathname)
  add_ftype(Q("MAKE-PATHNAME"),
    cons(Q("&KEY"), cons(list(Q(":CASE"), list(Q("MEMBER"), Q(":COMMON"), Q(":LOCAL"))), cons(list(Q(":HOST"), list(Q("OR"), Qstring, Qlist, list(Q("EQL"), Q(":UNSPECIFIC")))), list(list(Q(":DEVICE"), list(Q("OR"), Qstring, Qnull, list(Q("EQL"), Q(":UNSPECIFIC")))), list(Q(":DIRECTORY"), list(Q("OR"), Qstring, Qlist, Qnull, list(Q("MEMBER"), Q(":WILD"), Q(":WILD-INFERIOR"), Q(":UNSPECIFIC")))), list(Q(":NAME"), list(Q("OR"), Qstring, Qnull, list(Q("MEMBER"), Q(":WILD"), Q(":UNSPECIFIC")))), list(Q(":TYPE"), list(Q("OR"), Qstring, Qnull, list(Q("MEMBER"), Q(":WILD"), Q(":UNSPECIFIC")))), list(Q(":VERSION"), list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull, list(Q("MEMBER"), Q(":WILD"), Q(":NEWEST"), Q(":UNSPECIFIC")))), list(Q(":DEFAULTS"), Q("PATHNAME-DESIGNATOR")))))),
    Qpathname );

  // readtablep (function (t) t)
  add_ftype(Q("READTABLEP"),
    list(t),
    t );

  // rename-package (function (package-designator package-designator &optional (or string list)) package)
  add_ftype(Q("RENAME-PACKAGE"),
    list(Q("PACKAGE-DESIGNATOR"), Q("PACKAGE-DESIGNATOR"), Q("&OPTIONAL"), list(Q("OR"), Qstring, Qlist)),
    Qpackage );

  // set-difference (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("SET-DIFFERENCE"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // sixth (function (list) t)
  add_ftype(Q("SIXTH"),
    list(Qlist),
    t );

  // (setf sixth) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("SIXTH")),
    list(t, Qcons),
    t );

  // macroexpand-1 (function (t &optional t) (values t t))
  add_ftype(Q("MACROEXPAND-1"),
    list(t, Q("&OPTIONAL"), t),
    list(Q("VALUES"), t, t) );

  // float-radix (function (float) integer)
  add_ftype(Q("FLOAT-RADIX"),
    list(Qfloat),
    Qinteger );

  // write (function (t &key (:array t) (:base (integer 2 36)) (:case (member :upcase :downcase :capitalize)) (:circle t) (:escape t) (:gensym t) (:length (or unsigned-byte null)) (:level (or unsigned-byte null)) (:lines (or unsigned-byte null)) (:miser-width (or unsigned-byte null)) (:pprint-dispatch pp-dispatch-table) (:pretty t) (:radix t) (:readably t) (:right-margin (or unsigned-byte null)) (:stream stream-designator)) (values t))
  add_ftype(Q("WRITE"),
    cons(t, cons(Q("&KEY"), cons(list(Q(":ARRAY"), t), cons(list(Q(":BASE"), list(Qinteger, Fixnum::Encode(2), Fixnum::Encode(36))), cons(list(Q(":CASE"), list(Q("MEMBER"), Q(":UPCASE"), Q(":DOWNCASE"), Q(":CAPITALIZE"))), cons(list(Q(":CIRCLE"), t), cons(list(Q(":ESCAPE"), t), cons(list(Q(":GENSYM"), t), cons(list(Q(":LENGTH"), list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull)), cons(list(Q(":LEVEL"), list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull)), cons(list(Q(":LINES"), list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull)), cons(list(Q(":MISER-WIDTH"), list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull)), list(list(Q(":PPRINT-DISPATCH"), Qpp_dispatch_table), list(Q(":PRETTY"), t), list(Q(":RADIX"), t), list(Q(":READABLY"), t), list(Q(":RIGHT-MARGIN"), list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull)), list(Q(":STREAM"), Q("STREAM-DESIGNATOR"))))))))))))))),
    list(Q("VALUES"), t) );

  // array-total-size (function (array) sequence-index)
  add_ftype(Q("ARRAY-TOTAL-SIZE"),
    list(Qarray),
    Q("SEQUENCE-INDEX") );

  // last (function (list &optional sequence-index) t)
  add_ftype(Q("LAST"),
    list(Qlist, Q("&OPTIONAL"), Q("SEQUENCE-INDEX")),
    t );

  // reverse (function (sequence) sequence)
  add_ftype(Q("REVERSE"),
    list(Qsequence),
    Qsequence );

  // list (function (&rest t) list)
  add_ftype(Qlist,
    list(Q("&REST"), t),
    Qlist );

  // no-next-method (function (generic-function method &rest t) unspecified)
  add_ftype(Q("NO-NEXT-METHOD"),
    list(Qgeneric_function, Qmethod, Q("&REST"), t),
    Q("UNSPECIFIED") );

  // cell-error-name (function (cell-error) symbol)
  add_ftype(Q("CELL-ERROR-NAME"),
    list(Qcell_error),
    Qsymbol );

  // pathname-name (function (pathname &key (:case (member :local :common))) (or string null (member :wild :unspecific)))
  add_ftype(Q("PATHNAME-NAME"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":CASE"), list(Q("MEMBER"), Q(":LOCAL"), Q(":COMMON")))),
    list(Q("OR"), Qstring, Qnull, list(Q("MEMBER"), Q(":WILD"), Q(":UNSPECIFIC"))) );

  // translate-logical-pathname (function (pathname-designator) pathname)
  add_ftype(Q("TRANSLATE-LOGICAL-PATHNAME"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qpathname );

  // output-stream-p (function (stream) t)
  add_ftype(Q("OUTPUT-STREAM-P"),
    list(Qstream),
    t );

  // arithmetic-error-operation (function (arithmetic-error) function-designator)
  add_ftype(Q("ARITHMETIC-ERROR-OPERATION"),
    list(Q("ARITHMETIC-ERROR")),
    Q("FUNCTION-DESIGNATOR") );

  // evenp (function (integer) t)
  add_ftype(Q("EVENP"),
    list(Qinteger),
    t );

  // zerop (function (number) t)
  add_ftype(Q("ZEROP"),
    list(Qnumber),
    t );

  // abort (function (&optional (or condition null)) nil)
  add_ftype(Q("ABORT"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qcondition, Qnull)),
    nil );

  // get-setf-expansion (function ((or symbol cons) &optional t) (values list list list t t))
  add_ftype(Q("GET-SETF-EXPANSION"),
    list(list(Q("OR"), Qsymbol, Qcons), Q("&OPTIONAL"), t),
    list(Q("VALUES"), Qlist, Qlist, Qlist, t, t) );

  // get (function (symbol t &optional t) t)
  add_ftype(Q("GET"),
    list(Qsymbol, t, Q("&OPTIONAL"), t),
    t );

  // (setf get) (function (t symbol t &optional t) t)
  add_ftype(intern_setf_cell(Q("GET")),
    list(t, Qsymbol, t, Q("&OPTIONAL"), t),
    t );

  // nset-difference (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("NSET-DIFFERENCE"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // terpri (function (&optional (or stream (member nil t))) null)
  add_ftype(Q("TERPRI"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t))),
    Qnull );

  // array-row-major-index (function (array &rest sequence-index) sequence-index)
  add_ftype(Q("ARRAY-ROW-MAJOR-INDEX"),
    list(Qarray, Q("&REST"), Q("SEQUENCE-INDEX")),
    Q("SEQUENCE-INDEX") );

  // get-decoded-time (function nil (values (integer 0 59) (integer 0 59) (integer 0 23) (integer 1 31) (integer 1 12) (integer 1 *) (integer 0 6) t time-zone))
  add_ftype(Q("GET-DECODED-TIME"),
    nil,
    cons(Q("VALUES"), cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(59)), cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(59)), cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(23)), list(list(Qinteger, Fixnum::Encode(1), Fixnum::Encode(31)), list(Qinteger, Fixnum::Encode(1), Fixnum::Encode(12)), list(Qinteger, Fixnum::Encode(1), Q("*")), list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(6)), t, Q("TIME-ZONE")))))) );

  // integer-decode-float (function (float) (values integer integer integer))
  add_ftype(Q("INTEGER-DECODE-FLOAT"),
    list(Qfloat),
    list(Q("VALUES"), Qinteger, Qinteger, Qinteger) );

  // signal (function (condition-designator &rest t) null)
  add_ftype(Q("SIGNAL"),
    list(Q("CONDITION-DESIGNATOR"), Q("&REST"), t),
    Qnull );

  // set (function (symbol t) t)
  add_ftype(Q("SET"),
    list(Qsymbol, t),
    t );

  // byte (function (unsigned-byte unsigned-byte) bytespec)
  add_ftype(Q("BYTE"),
    list(Q("UNSIGNED-BYTE"), Q("UNSIGNED-BYTE")),
    Q("BYTESPEC") );

  // listen (function (&optional stream-designator) t)
  add_ftype(Q("LISTEN"),
    list(Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    t );

  // char< (function (&rest character) t)
  add_ftype(Q("CHAR<"),
    list(Q("&REST"), Qcharacter),
    t );

  // elt (function (sequence sequence-index) t)
  add_ftype(Q("ELT"),
    list(Qsequence, Q("SEQUENCE-INDEX")),
    t );

  // (setf elt) (function (t sequence sequence-index) t)
  add_ftype(intern_setf_cell(Q("ELT")),
    list(t, Qsequence, Q("SEQUENCE-INDEX")),
    t );

  // char-not-greaterp (function (&rest character) t)
  add_ftype(Q("CHAR-NOT-GREATERP"),
    list(Q("&REST"), Qcharacter),
    t );

  // string/= (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING/="),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // set-macro-character (function (character function-designator &optional t readtable-designator) (eql t))
  add_ftype(Q("SET-MACRO-CHARACTER"),
    list(Qcharacter, Q("FUNCTION-DESIGNATOR"), Q("&OPTIONAL"), t, Q("READTABLE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // find-class (function (symbol &optional t t) (or class null))
  add_ftype(Q("FIND-CLASS"),
    list(Qsymbol, Q("&OPTIONAL"), t, t),
    list(Q("OR"), Qclass, Qnull) );

  // (setf find-class) (function ((or class null) symbol &optional t t) (or class null))
  add_ftype(intern_setf_cell(Q("FIND-CLASS")),
    list(list(Q("OR"), Qclass, Qnull), Qsymbol, Q("&OPTIONAL"), t, t),
    list(Q("OR"), Qclass, Qnull) );

  // member-if (function (predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("MEMBER-IF"),
    list(Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // nset-exclusive-or (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("NSET-EXCLUSIVE-OR"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // make-hash-table (function (&key (:test (or function (member eq eql equal equalp))) (:size sequence-index) (:rehash-size (or (integer 1 *) (float (1) *))) (:rehash-threshold (real 0 1))) (values hash-table))
  add_ftype(Q("MAKE-HASH-TABLE"),
    list(Q("&KEY"), list(Q(":TEST"), list(Q("OR"), Qfunction, list(Q("MEMBER"), Q("EQ"), Q("EQL"), Q("EQUAL"), Q("EQUALP")))), list(Q(":SIZE"), Q("SEQUENCE-INDEX")), list(Q(":REHASH-SIZE"), list(Q("OR"), list(Qinteger, Fixnum::Encode(1), Q("*")), list(Qfloat, list(Fixnum::Encode(1)), Q("*")))), list(Q(":REHASH-THRESHOLD"), list(Qreal, Fixnum::Encode(0), Fixnum::Encode(1)))),
    list(Q("VALUES"), Qhash_table) );

  // slot-exists-p (function (t symbol) t)
  add_ftype(Q("SLOT-EXISTS-P"),
    list(t, Qsymbol),
    t );

  // char-upcase (function (character) character)
  add_ftype(Q("CHAR-UPCASE"),
    list(Qcharacter),
    Qcharacter );

  // cosh (function (number) number)
  add_ftype(Q("COSH"),
    list(Qnumber),
    Qnumber );

  // enough-namestring (function (pathname-designator &optional pathname-designator) string)
  add_ftype(Q("ENOUGH-NAMESTRING"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&OPTIONAL"), Q("PATHNAME-DESIGNATOR")),
    Qstring );

  // get-macro-character (function (character &optional readtable-designator) (values (or function null) t))
  add_ftype(Q("GET-MACRO-CHARACTER"),
    list(Qcharacter, Q("&OPTIONAL"), Q("READTABLE-DESIGNATOR")),
    list(Q("VALUES"), Q("FUNCTION-DESIGNATOR"), t) );

  // string-right-trim (function (sequence string-designator) string)
  add_ftype(Q("STRING-RIGHT-TRIM"),
    list(Qsequence, Q("STRING-DESIGNATOR")),
    Qstring );

  // third (function (list) t)
  add_ftype(Q("THIRD"),
    list(Qlist),
    t );

  // (setf third) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("THIRD")),
    list(t, Qcons),
    t );

  // read-preserving-whitespace (function (&optional stream-designator t t t) t)
  add_ftype(Q("READ-PRESERVING-WHITESPACE"),
    list(Q("&OPTIONAL"), Q("STREAM-DESIGNATOR"), t, t, t),
    t );

  // string-downcase (function (string &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("STRING-DOWNCASE"),
    list(Q("STRING-DESIGNATOR"), Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // char-not-equal (function (&rest character) t)
  add_ftype(Q("CHAR-NOT-EQUAL"),
    list(Q("&REST"), Qcharacter),
    t );

  // vector (function (&rest t) simple-vector)
  add_ftype(Qvector,
    list(Q("&REST"), t),
    Qsimple_vector );

  // encode-universal-time (function ((integer 0 59) (integer 0 59) (integer 0 23) (integer 1 31) (integer 1 12) (integer 1 *) &optional (rational -24 24)) integer)
  add_ftype(Q("ENCODE-UNIVERSAL-TIME"),
    cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(59)), cons(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(59)), list(list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(23)), list(Qinteger, Fixnum::Encode(1), Fixnum::Encode(31)), list(Qinteger, Fixnum::Encode(1), Fixnum::Encode(12)), list(Qinteger, Fixnum::Encode(1), Q("*")), Q("&OPTIONAL"), list(Qrational, Fixnum::Encode(-24), Fixnum::Encode(24))))),
    Qinteger );

  // random-state-p (function (t) t)
  add_ftype(Q("RANDOM-STATE-P"),
    list(t),
    t );

  // scale-float (function (float integer) float)
  add_ftype(Q("SCALE-FLOAT"),
    list(Qfloat, Qinteger),
    Qfloat );

  // list-all-packages (function nil list)
  add_ftype(Q("LIST-ALL-PACKAGES"),
    nil,
    Qlist );

  // machine-type (function nil simple-string)
  add_ftype(Q("MACHINE-TYPE"),
    nil,
    Qsimple_string );

  // integerp (function (t) t)
  add_ftype(Q("INTEGERP"),
    list(t),
    t );

  // mapcar (function (function-designator list &rest list) list)
  add_ftype(Q("MAPCAR"),
    list(Q("FUNCTION-DESIGNATOR"), Qlist, Q("&REST"), Qlist),
    Qlist );

  // package-name (function (package-designator) (or string null))
  add_ftype(Q("PACKAGE-NAME"),
    list(Q("PACKAGE-DESIGNATOR")),
    list(Q("OR"), Qstring, Qnull) );

  // cadaar (function (list) t)
  add_ftype(Q("CADAAR"),
    list(Qlist),
    t );

  // (setf cadaar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CADAAR")),
    list(t, Qcons),
    t );

  // cddadr (function (list) t)
  add_ftype(Q("CDDADR"),
    list(Qlist),
    t );

  // (setf cddadr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDDADR")),
    list(t, Qcons),
    t );

  // find-if (function (test-1-function sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) t)
  add_ftype(Q("FIND-IF"),
    cons(Q("TEST-1-FUNCTION"), list(Qsequence, Q("&KEY"), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")))),
    t );

  // set-dispatch-macro-character (function (character character (or function symbol) &optional readtable-designator) (eql t))
  add_ftype(Q("SET-DISPATCH-MACRO-CHARACTER"),
    list(Qcharacter, Qcharacter, Q("FUNCTION-DESIGNATOR"), Q("&OPTIONAL"), Q("READTABLE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // caddar (function (list) t)
  add_ftype(Q("CADDAR"),
    list(Qlist),
    t );

  // (setf caddar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CADDAR")),
    list(t, Qcons),
    t );

  // cddddr (function (list) t)
  add_ftype(Q("CDDDDR"),
    list(Qlist),
    t );

  // (setf cddddr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDDDDR")),
    list(t, Qcons),
    t );

  // seventh (function (list) t)
  add_ftype(Q("SEVENTH"),
    list(Qlist),
    t );

  // (setf seventh) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("SEVENTH")),
    list(t, Qcons),
    t );

  // sxhash (function (t) positive-fixnum
  add_ftype(Q("SXHASH"),
    list(t),
    Q("POSITIVE-FIXNUM") );

  // deposit-field (function (integer bytespec integer) integer)
  add_ftype(Q("DEPOSIT-FIELD"),
    list(Qinteger, Q("BYTESPEC"), Qinteger),
    Qinteger );

  // maphash (function (function-designator hash-table) null)
  add_ftype(Q("MAPHASH"),
    list(Q("FUNCTION-DESIGNATOR"), Qhash_table),
    Qnull );

  // stream-element-type (function (stream) type-specifier)
  add_ftype(Q("STREAM-ELEMENT-TYPE"),
    list(Qstream),
    Q("TYPE-SPECIFIER") );

  // member-if-not (function (predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("MEMBER-IF-NOT"),
    list(Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // * (function (&rest number) number)
  add_ftype(Q("*"),
    list(Q("&REST"), Qnumber),
    Qnumber );

  // allocate-instance (function (class &key &allow-other-keys) t)
  add_ftype(Q("ALLOCATE-INSTANCE"),
    list(Qclass, Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // get-dispatch-macro-character (function (character character &optional readtable-designator) (or function null))
  add_ftype(Q("GET-DISPATCH-MACRO-CHARACTER"),
    list(Qcharacter, Qcharacter, Q("&OPTIONAL"), Q("READTABLE-DESIGNATOR")),
    list(Q("OR"), Qfunction, Qnull) );

  // adjustable-array-p (function (array) t)
  add_ftype(Q("ADJUSTABLE-ARRAY-P"),
    list(Qarray),
    t );

  // streamp (function (t) t)
  add_ftype(Q("STREAMP"),
    list(t),
    t );

  // store-value (function (&optional (or condition null)) null)
  add_ftype(Q("STORE-VALUE"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qcondition, Qnull)),
    Qnull );

  // char>= (function (&rest character) t)
  add_ftype(Q("CHAR>="),
    list(Q("&REST"), Qcharacter),
    t );

  // export (function ((or list symbol) &optional package-designator) (eql t))
  add_ftype(Q("EXPORT"),
    list(list(Q("OR"), Qlist, Qsymbol), Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // > (function (real &rest real) t)
  add_ftype(Q(">"),
    list(Qreal, Q("&REST"), Qreal),
    t );

  // shadow (function ((or string list) &optional package-designator) (eql t))
  add_ftype(Q("SHADOW"),
    list(list(Q("OR"), Q("STRING-DESIGNATOR"), Qlist), Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // digit-char-p (function (character &optional (integer 2 36)) (or (integer 0 35) null))
  add_ftype(Q("DIGIT-CHAR-P"),
    list(Qcharacter, Q("&OPTIONAL"), list(Qinteger, Fixnum::Encode(2), Fixnum::Encode(36))),
    list(Q("OR"), list(Qinteger, Fixnum::Encode(0), Fixnum::Encode(35)), Qnull) );

  // pathname-host (function (pathname &key (:case (member :local :common))) (or string list (eql :unspecific)))
  add_ftype(Q("PATHNAME-HOST"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":CASE"), list(Q("MEMBER"), Q(":LOCAL"), Q(":COMMON")))),
    list(Q("OR"), Qstring, Qlist, list(Q("EQL"), Q(":UNSPECIFIC"))) );

  // getf (function (list t &optional t) t)
  add_ftype(Q("GETF"),
    list(Qlist, t, Q("&OPTIONAL"), t),
    t );

  // unuse-package (function ((or package-designator list) &optional package-designator) (eql t))
  add_ftype(Q("UNUSE-PACKAGE"),
    list(list(Q("OR"), Q("PACKAGE-DESIGNATOR"), Qlist), Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // array-displacement (function (array) (values (or array null) sequence-index))
  add_ftype(Q("ARRAY-DISPLACEMENT"),
    list(Qarray),
    list(Q("VALUES"), list(Q("OR"), Qarray, Qnull), Q("SEQUENCE-INDEX")) );

  // nsubstitute (function (t t sequence &key (:start sequence-index) (:end sequence-end) (:from-end t) (:key key-function) (:count sequence-end) (:test test-2-function) (:test-not test-2-function)) sequence)
  add_ftype(Q("NSUBSTITUTE"),
    cons(t, cons(t, cons(Qsequence, cons(Q("&KEY"), cons(list(Q(":START"), Q("SEQUENCE-INDEX")), list(list(Q(":END"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":COUNT"), Q("SEQUENCE-END")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION")))))))),
    Qsequence );

  // parse-namestring (function ((or string pathname stream) &optional (or string list (eql :unspecific) null) pathname-designator &key (:start sequence-index) (:end sequence-end) (:junk-allowed t)) (values pathname sequence-index))
  add_ftype(Q("PARSE-NAMESTRING"),
    list(
        Q("PATHNAME-DESIGNATOR"),
        Q("&OPTIONAL"),
            Q("PATHNAME-HOST-DESIGNATOR"),
            Q("PATHNAME-DESIGNATOR"), 
        Q("&KEY"), 
             list(Q(":START"), Q("SEQUENCE-INDEX")), 
             list(Q(":END"), Q("SEQUENCE-END")), 
             list(Q(":JUNK-ALLOWED"), t) ),
    list(Q("VALUES"), Qpathname, Q("SEQUENCE-INDEX")) );

  // directory-namestring (function (pathname-designator) string)
  add_ftype(Q("DIRECTORY-NAMESTRING"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qstring );

  // byte-size (function (bytespec) unsigned-byte)
  add_ftype(Q("BYTE-SIZE"),
    list(Q("BYTESPEC")),
    Q("UNSIGNED-BYTE") );

  // string-not-lessp (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING-NOT-LESSP"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // map (function (type-specifier function-designator sequence &rest sequence) sequence)
  add_ftype(Q("MAP"),
    list(Q("TYPE-SPECIFIER"), Q("FUNCTION-DESIGNATOR"), Qsequence, Q("&REST"), Qsequence),
    Qsequence );

  // float-precision (function (float) integer)
  add_ftype(Q("FLOAT-PRECISION"),
    list(Qfloat),
    Qinteger );

  // realpart (function (number) real)
  add_ftype(Q("REALPART"),
    list(Qnumber),
    Qreal );

  // tailp (function (t list) list)
  add_ftype(Q("TAILP"),
    list(t, Qlist),
    Qlist );

  // nreverse (function (sequence) sequence)
  add_ftype(Q("NREVERSE"),
    list(Qsequence),
    Qsequence );

  // translate-pathname (function (pathname-designator pathname-designator pathname-designator &key) pathname)
  add_ftype(Q("TRANSLATE-PATHNAME"),
    list(Q("PATHNAME-DESIGNATOR"), Q("PATHNAME-DESIGNATOR"), Q("PATHNAME-DESIGNATOR"), Q("&KEY")),
    Qpathname );

  // cdadr (function (list) t)
  add_ftype(Q("CDADR"),
    list(Qlist),
    t );

  // (setf cdadr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDADR")),
    list(t, Qcons),
    t );

  // compile-file (function (pathname-designator &key (:output-file pathname-designator) (:verbose t) (:print t) (:exteranl-format t)) (values pathname t t))
  add_ftype(Q("COMPILE-FILE"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":OUTPUT-FILE"), Q("PATHNAME-DESIGNATOR")), list(Q(":VERBOSE"), t), list(Q(":PRINT"), t), list(Q(":EXTERANL-FORMAT"), t)),
    list(Q("VALUES"), Qpathname, t, t) );

  // cdddr (function (list) t)
  add_ftype(Q("CDDDR"),
    list(Qlist),
    t );

  // (setf cdddr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDDDR")),
    list(t, Qcons),
    t );

  // bit-not (function ((array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-NOT"),
    list(list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // remove-if (function (test-1-function sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) sequence)
  add_ftype(Q("REMOVE-IF"),
    cons(Q("TEST-1-FUNCTION"), list(Qsequence, Q("&KEY"), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")))),
    Qsequence );

  // second (function (list) t)
  add_ftype(Q("SECOND"),
    list(Qlist),
    t );

  // (setf second) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("SECOND")),
    list(t, Qcons),
    t );

  // cdr (function (list) t)
  add_ftype(Q("CDR"),
    list(Qlist),
    t );

  // (setf cdr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDR")),
    list(t, Qcons),
    t );

  // delete-if (function (test-1-function sequence &key (:count (or integer null)) (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) sequence)
  add_ftype(Q("DELETE-IF"),
    cons(Q("TEST-1-FUNCTION"), cons(Qsequence, list(Q("&KEY"), list(Q(":COUNT"), list(Q("OR"), Qinteger, Qnull)), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION"))))),
    Qsequence );

  // import (function ((or list symbol) &optional package-designator) (eql t))
  add_ftype(Q("IMPORT"),
    list(list(Q("OR"), Qlist, Qsymbol), Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // symbolp (function (t) t)
  add_ftype(Q("SYMBOLP"),
    list(t),
    t );

  // equalp (function (t t) t)
  add_ftype(Q("EQUALP"),
    list(t, t),
    t );

  // abs (function (number) number)
  add_ftype(Q("ABS"),
    list(Qnumber),
    Qnumber );

  // nsublis (function (t list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("NSUBLIS"),
    list(t, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // truncate (function (real &optional real) (values integer real))
  add_ftype(Q("TRUNCATE"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qinteger, Qreal) );

  // bit-and (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-AND"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // no-applicable-method (function (generic-function &rest t) t)
  add_ftype(Q("NO-APPLICABLE-METHOD"),
    list(Qgeneric_function, Q("&REST"), t),
    t );

  // assoc-if-not (function (predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("ASSOC-IF-NOT"),
    list(Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // char-equal (function (&rest character) t)
  add_ftype(Q("CHAR-EQUAL"),
    list(Q("&REST"), Qcharacter),
    t );

  // cis (function (real) number)
  add_ftype(Q("CIS"),
    list(Qreal),
    Qnumber );

  // realp (function (t) t)
  add_ftype(Q("REALP"),
    list(t),
    t );

  // get-universal-time (function nil integer)
  add_ftype(Q("GET-UNIVERSAL-TIME"),
    nil,
    Qinteger );

  // logandc2 (function (integer integer) integer)
  add_ftype(Q("LOGANDC2"),
    list(Qinteger, Qinteger),
    Qinteger );

  // interactive-stream-p (function (stream) t)
  add_ftype(Q("INTERACTIVE-STREAM-P"),
    list(Qstream),
    t );

  // slot-missing (function (class t symbol (member setf slot-boundp slot-makunbound slot-value) &optional t) t)
  add_ftype(Q("SLOT-MISSING"),
    list(Qclass, t, Qsymbol, list(Q("MEMBER"), Q("SETF"), Q("SLOT-BOUNDP"), Q("SLOT-MAKUNBOUND"), Q("SLOT-VALUE")), Q("&OPTIONAL"), t),
    t );

  // print-object (function (t stream) (values t))
  add_ftype(Q("PRINT-OBJECT"),
    list(t, Qstream),
    list(Q("VALUES"), t) );

  // fboundp (function (function-name) t)
  add_ftype(Q("FBOUNDP"),
    list(Q("FUNCTION-NAME")),
    t );

  // package-error-package (function (package-error) package-designator)
  add_ftype(Q("PACKAGE-ERROR-PACKAGE"),
    list(Qpackage_error),
    Q("PACKAGE-DESIGNATOR") );

  // adjust-array (function (array (or integer list) &key (:element-type type-specifier) (:initial-element t) (:initial-contents sequence) (:adjustable t) (:fill-pointer (or null (eql t) sequence-index)) (:displaced-to (or array null)) (:displaced-index-offset (or sequence-index null))) (values array))
  add_ftype(Q("ADJUST-ARRAY"),
    cons(Qarray, cons(list(Q("OR"), Qinteger, Qlist), cons(Q("&KEY"), cons(list(Q(":ELEMENT-TYPE"), Q("TYPE-SPECIFIER")), list(list(Q(":INITIAL-ELEMENT"), t), list(Q(":INITIAL-CONTENTS"), Qsequence), list(Q(":ADJUSTABLE"), t), list(Q(":FILL-POINTER"), list(Q("OR"), Qnull, list(Q("EQL"), t), Q("SEQUENCE-INDEX"))), list(Q(":DISPLACED-TO"), list(Q("OR"), Qarray, Qnull)), list(Q(":DISPLACED-INDEX-OFFSET"), list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull))))))),
    list(Q("VALUES"), Qarray) );

  // char= (function (&rest character) t)
  add_ftype(Q("CHAR="),
    list(Q("&REST"), Qcharacter),
    t );

  // arithmetic-error-operands (function (arithmetic-error) list)
  add_ftype(Q("ARITHMETIC-ERROR-OPERANDS"),
    list(Q("ARITHMETIC-ERROR")),
    Qlist );

  // make-echo-stream (function (stream stream) echo-stream)
  add_ftype(Q("MAKE-ECHO-STREAM"),
    list(Qstream, Qstream),
    Qecho_stream );

  // provide (function (string-designator) t)
  add_ftype(Q("PROVIDE"),
    list(Q("STRING-DESIGNATOR")),
    t );

  // upgraded-array-element-type (function (type-specifier &optional t) type-specifier)
  add_ftype(Q("UPGRADED-ARRAY-ELEMENT-TYPE"),
    list(Q("TYPE-SPECIFIER"), Q("&OPTIONAL"), t),
    Q("TYPE-SPECIFIER") );

  // ftruncate (function (real &optional real) (values float real))
  add_ftype(Q("FTRUNCATE"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qfloat, Qreal) );

  // type-error-datum (function (type-error) t)
  add_ftype(Q("TYPE-ERROR-DATUM"),
    list(Qtype_error),
    t );

  // nbutlast (function (list &optional sequence-index) list)
  add_ftype(Q("NBUTLAST"),
    list(Qlist, Q("&OPTIONAL"), Q("SEQUENCE-INDEX")),
    Qlist );

  // method-combination-error (function (format-control &rest t) t)
  add_ftype(Q("METHOD-COMBINATION-ERROR"),
    list(Q("FORMAT-CONTROL"), Q("&REST"), t),
    t );

  // package-used-by-list (function (package-designator) list)
  add_ftype(Q("PACKAGE-USED-BY-LIST"),
    list(Q("PACKAGE-DESIGNATOR")),
    Qlist );

  // pprint-dispatch (function (&optional (or pp-dispatch-table null)) (values (or symbol function) t))
  add_ftype(Q("PPRINT-DISPATCH"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qpp_dispatch_table, Qnull)),
    list(Q("VALUES"), Q("FUNCTION-DESIGNATOR"), t) );

  // integer-length (function (integer) unsigned-byte)
  add_ftype(Q("INTEGER-LENGTH"),
    list(Qinteger),
    Q("UNSIGNED-BYTE") );

  // floatp (function (t) t)
  add_ftype(Q("FLOATP"),
    list(t),
    t );

  // copy-structure (function (structure-object) structure-object)
  add_ftype(Q("COPY-STRUCTURE"),
    list(Qstructure_object),
    Q("structure-object") );

  // rassoc (function (t list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("RASSOC"),
    list(t, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // add-method (function (generic-function method) generic-function)
  add_ftype(Q("ADD-METHOD"),
    list(Qgeneric_function, Qmethod),
    Qgeneric_function );

  // stream-external-format (function (stream) t)
  add_ftype(Q("STREAM-EXTERNAL-FORMAT"),
    list(Qstream),
    t );

  // minusp (function (real) t)
  add_ftype(Q("MINUSP"),
    list(Qreal),
    t );

  // functionp (function (t) t)
  add_ftype(Q("FUNCTIONP"),
    list(t),
    t );

  // make-synonym-stream (function (symbol) synonym-stream)
  add_ftype(Q("MAKE-SYNONYM-STREAM"),
    list(Qsymbol),
    Qsynonym_stream );

  // find-package (function (string-designator) (or package null))
  add_ftype(Q("FIND-PACKAGE"),
    list(Q("STRING-DESIGNATOR")),
    list(Q("OR"), Qpackage, Qnull) );

  // namestring (function (pathname-designator) string)
  add_ftype(Q("NAMESTRING"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qstring );

  // stream-error-stream (function (stream-error) stream)
  add_ftype(Q("STREAM-ERROR-STREAM"),
    list(Qstream_error),
    Qstream );

  // first (function (list) t)
  add_ftype(Q("FIRST"),
    list(Qlist),
    t );

  // (setf first) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("FIRST")),
    list(t, Qcons),
    t );

  // make-instances-obsolete (function (class-designator) class)
  add_ftype(Q("MAKE-INSTANCES-OBSOLETE"),
    list(Q("CLASS-DESIGNATOR")),
    Qclass );

  // string-equal (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) t)
  add_ftype(Q("STRING-EQUAL"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    t );

  // bit-eqv (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-EQV"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // ash (function (integer integer) integer)
  add_ftype(Q("ASH"),
    list(Qinteger, Qinteger),
    Qinteger );

  // simple-vector-p (function (t) t)
  add_ftype(Q("SIMPLE-VECTOR-P"),
    list(t),
    t );

  // count-if-not (function (test-1-function sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) sequence-index)
  add_ftype(Q("COUNT-IF-NOT"),
    cons(Q("TEST-1-FUNCTION"), list(Qsequence, Q("&KEY"), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")))),
    Q("SEQUENCE-INDEX") );

  // expt (function (number number) number)
  add_ftype(Q("EXPT"),
    list(Qnumber, Qnumber),
    Qnumber );

  // row-major-aref (function (array sequence-index) t)
  add_ftype(Q("ROW-MAJOR-AREF"),
    list(Qarray, Q("SEQUENCE-INDEX")),
    t );

  // (setf row-major-aref) (function (t array sequence-index) t)
  add_ftype(intern_setf_cell(Q("ROW-MAJOR-AREF")),
    list(t, Qarray, Q("SEQUENCE-INDEX")),
    t );

  // + (function (&rest number) number)
  add_ftype(Q("+"),
    list(Q("&REST"), Qnumber),
    Qnumber );

  // string> (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING>"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // type-error-expected-type (function (type-error) type-specifier)
  add_ftype(Q("TYPE-ERROR-EXPECTED-TYPE"),
    list(Qtype_error),
    Q("TYPE-SPECIFIER") );

  // make-array (function ((or integer list) &key (:element-type type-specifier) (:initial-element t) (:initial-contents sequence) (:adjustable t) (:fill-pointer (or null (eql t) sequence-index)) (:displaced-to (or array null)) (:displaced-index-offset (or sequence-index null))) (values array))
  add_ftype(Q("MAKE-ARRAY"),
    cons(list(Q("OR"), Qinteger, Qlist), cons(Q("&KEY"), cons(list(Q(":ELEMENT-TYPE"), Q("TYPE-SPECIFIER")), list(list(Q(":INITIAL-ELEMENT"), t), list(Q(":INITIAL-CONTENTS"), Qsequence), list(Q(":ADJUSTABLE"), t), list(Q(":FILL-POINTER"), list(Q("OR"), Qnull, list(Q("EQL"), t), Q("SEQUENCE-INDEX"))), list(Q(":DISPLACED-TO"), list(Q("OR"), Qarray, Qnull)), list(Q(":DISPLACED-INDEX-OFFSET"), list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull)))))),
    list(Q("VALUES"), Qarray) );

  // assoc (function (t list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("ASSOC"),
    list(t, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // every (function (function sequence &rest sequence) t)
  add_ftype(Q("EVERY"),
    list(Qfunction, Qsequence, Q("&REST"), Qsequence),
    t );

  // fmakunbound (function (function-name) function-name)
  add_ftype(Q("FMAKUNBOUND"),
    list(Q("FUNCTION-NAME")),
    Q("FUNCTION-NAME") );

  // make-load-form-saving-slots (function (t &key (:slot-names list) (:environment (or environment null))) (values t t))
  add_ftype(Q("MAKE-LOAD-FORM-SAVING-SLOTS"),
    list(t, Q("&KEY"), list(Q(":SLOT-NAMES"), Qlist), list(Q(":ENVIRONMENT"), list(Q("OR"), Qenvironment, Qnull))),
    list(Q("VALUES"), t, t) );

  // random (function ((or (integer 0 *) (float 0 *)) &optional random-state) (real 0 *))
  add_ftype(Q("RANDOM"),
    list(list(Q("OR"), list(Qinteger, Fixnum::Encode(0), Q("*")), list(Qfloat, Fixnum::Encode(0), Q("*"))), Q("&OPTIONAL"), Q("RANDOM-STATE")),
    list(Qreal, Fixnum::Encode(0), Q("*")) );

  // write-string (function (string &optional (or stream (member nil t)) &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("WRITE-STRING"),
    list(Qstring, Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t)), Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // numerator (function (rational) integer)
  add_ftype(Q("NUMERATOR"),
    list(Qrational),
    Qinteger );

  // cdaar (function (list) t)
  add_ftype(Q("CDAAR"),
    list(Qlist),
    t );

  // (setf cdaar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDAAR")),
    list(t, Qcons),
    t );

  // bit-andc1 (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-ANDC1"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // cddar (function (list) t)
  add_ftype(Q("CDDAR"),
    list(Qlist),
    t );

  // (setf cddar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDDAR")),
    list(t, Qcons),
    t );

  // some (function (function sequence &rest sequence) t)
  add_ftype(Q("SOME"),
    list(Qfunction, Qsequence, Q("&REST"), Qsequence),
    t );

  // complexp (function (t) t)
  add_ftype(Q("COMPLEXP"),
    list(t),
    t );

  // special-operator-p (function (symbol) t)
  add_ftype(Q("SPECIAL-OPERATOR-P"),
    list(Qsymbol),
    t );

  // constantly (function (t) function)
  add_ftype(Q("CONSTANTLY"),
    list(t),
    Qfunction );

  // fifth (function (list) t)
  add_ftype(Q("FIFTH"),
    list(Qlist),
    t );

  // (setf fifth) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("FIFTH")),
    list(t, Qcons),
    t );

  // unintern (function (symbol &optional package-designator) t)
  add_ftype(Q("UNINTERN"),
    list(Qsymbol, Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    t );

  // bit-orc1 (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-ORC1"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // gensym (function (&optional (or string unsigned-byte)) symbol)
  add_ftype(Q("GENSYM"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qstring, Q("UNSIGNED-BYTE"))),
    Qsymbol );

  // load (function ((or pathname-designator stream) &key (:verbose t) (:print t) (:if-does-not-exist t) (:external-format t)) t)
  add_ftype(Q("LOAD"),
    list(list(Q("OR"), Q("PATHNAME-DESIGNATOR"), Qstream), Q("&KEY"), list(Q(":VERBOSE"), t), list(Q(":PRINT"), t), list(Q(":IF-DOES-NOT-EXIST"), t), list(Q(":EXTERNAL-FORMAT"), t)),
    t );

  // package-shadowing-symbols (function (package-designator) list)
  add_ftype(Q("PACKAGE-SHADOWING-SYMBOLS"),
    list(Q("PACKAGE-DESIGNATOR")),
    Qlist );

  // remprop (function (symbol t) t)
  add_ftype(Q("REMPROP"),
    list(Qsymbol, t),
    t );

  // char-lessp (function (&rest character) t)
  add_ftype(Q("CHAR-LESSP"),
    list(Q("&REST"), Qcharacter),
    t );

  // map-into (function (sequence function-designator &rest sequence) sequence)
  add_ftype(Q("MAP-INTO"),
    list(Qsequence, Q("FUNCTION-DESIGNATOR"), Q("&REST"), Qsequence),
    Qsequence );

  // pprint-tab (function ((member :line :section :line-relative :section-relative) unsigned-byte unsigned-byte &optional stream) (values null))
  add_ftype(Q("PPRINT-TAB"),
    list(list(Q("MEMBER"), Q(":LINE"), Q(":SECTION"), Q(":LINE-RELATIVE"), Q(":SECTION-RELATIVE")), Q("UNSIGNED-BYTE"), Q("UNSIGNED-BYTE"), Q("&OPTIONAL"), Qstream),
    list(Q("VALUES"), Qnull) );

  // break (function (format-control &rest t) null)
  add_ftype(Q("BREAK"),
    list(Q("FORMAT-CONTROL"), Q("&REST"), t),
    Qnull );

  // rest (function (list) t)
  add_ftype(Q("REST"),
    list(Qlist),
    t );

  // (setf rest) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("REST")),
    list(t, Qcons),
    t );

  // mapcan (function (function-designator list &rest list) list)
  add_ftype(Q("MAPCAN"),
    list(Q("FUNCTION-DESIGNATOR"), Qlist, Q("&REST"), Qlist),
    Qlist );

  // string>= (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING>="),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // string-left-trim (function (sequence string-designator) string)
  add_ftype(Q("STRING-LEFT-TRIM"),
    list(Qsequence, Q("STRING-DESIGNATOR")),
    Qstring );

  // maplist (function (function-designator list &rest list) list)
  add_ftype(Q("MAPLIST"),
    list(Q("FUNCTION-DESIGNATOR"), Qlist, Q("&REST"), Qlist),
    Qlist );

  // array-dimension (function (array sequence-index) sequence-index)
  add_ftype(Q("ARRAY-DIMENSION"),
    list(Qarray, Q("SEQUENCE-INDEX")),
    Q("SEQUENCE-INDEX") );

  // symbol-function (function (symbol) function)
  add_ftype(Q("SYMBOL-FUNCTION"),
    list(Qsymbol),
    Qfunction );

  // (setf symbol-function) (function (function symbol) function)
  add_ftype(intern_setf_cell(Q("SYMBOL-FUNCTION")),
    list(Qfunction, Qsymbol),
    Qfunction );

  // compile (function (function-name &optional (or list function)) (values (or function-name compiled-function) t t))
  add_ftype(Q("COMPILE"),
    list(Q("FUNCTION-NAME"), Q("&OPTIONAL"), list(Q("OR"), Qlist, Qfunction)),
    list(Q("VALUES"), list(Q("OR"), Q("FUNCTION-NAME"), Qcompiled_function), t, t) );

  // compile-file-pathname (function (pathname-designator &key (:output-file pathname-designator)) pathname)
  add_ftype(Q("COMPILE-FILE-PATHNAME"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":OUTPUT-FILE"), Q("PATHNAME-DESIGNATOR"))),
    Qpathname );

  // open-stream-p (function (stream) t)
  add_ftype(Q("OPEN-STREAM-P"),
    list(Qstream),
    t );

  // notany (function (function sequence &rest sequence) t)
  add_ftype(Q("NOTANY"),
    list(Qfunction, Qsequence, Q("&REST"), Qsequence),
    t );

  // intersection (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("INTERSECTION"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // position-if-not (function (test-1-function sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) (or sequence-index null))
  add_ftype(Q("POSITION-IF-NOT"),
    cons(Q("TEST-1-FUNCTION"), list(Qsequence, Q("&KEY"), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // exp (function (number) number)
  add_ftype(Q("EXP"),
    list(Qnumber),
    Qnumber );

  // bit (function (bit-vector &rest sequence-index) bit)
  add_ftype(Q("BIT"),
    list(Qbit_vector, Q("&REST"), Q("SEQUENCE-INDEX")),
    Q("BIT") );

  // (setf bit) (function (bit (array bit) &rest sequence-index) bit)
  add_ftype(intern_setf_cell(Q("BIT")),
    list(Q("BIT"), list(Qarray, Q("BIT")), Q("&REST"), Q("SEQUENCE-INDEX")),
    Q("BIT") );

  // concatenate (function (type-specifier &rest sequence) sequence)
  add_ftype(Q("CONCATENATE"),
    list(Q("TYPE-SPECIFIER"), Q("&REST"), Qsequence),
    Qsequence );

  // mapcon (function (function-designator list &rest list) list)
  add_ftype(Q("MAPCON"),
    list(Q("FUNCTION-DESIGNATOR"), Qlist, Q("&REST"), Qlist),
    Qlist );

  // rational (function (real) rational)
  add_ftype(Qrational,
    list(Qreal),
    Qrational );

  // remhash (function (t hash-table) t)
  add_ftype(Q("REMHASH"),
    list(t, Qhash_table),
    t );

  // write-sequence (function (sequence stream &key (:start sequence-index) (:end sequence-end)) sequence)
  add_ftype(Q("WRITE-SEQUENCE"),
    list(Qsequence, Qstream, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qsequence );

  // invoke-debugger (function (condition) nil)
  add_ftype(Q("INVOKE-DEBUGGER"),
    list(Qcondition),
    nil );

  // yes-or-no-p (function (&optional format-control &rest t) t)
  add_ftype(Q("YES-OR-NO-P"),
    list(Q("&OPTIONAL"), Q("FORMAT-CONTROL"), Q("&REST"), t),
    t );

  // char> (function (&rest character) t)
  add_ftype(Q("CHAR>"),
    list(Q("&REST"), Qcharacter),
    t );

  // finish-output (function (&optional stream-designator) null)
  add_ftype(Q("FINISH-OUTPUT"),
    list(Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    Qnull );

  // byte-position (function (bytespec) unsigned-byte)
  add_ftype(Q("BYTE-POSITION"),
    list(Q("BYTESPEC")),
    Q("UNSIGNED-BYTE") );

  // nsubst-if (function (t predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("NSUBST-IF"),
    list(t, Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // max (function (real &rest real) real)
  add_ftype(Q("MAX"),
    list(Qreal, Q("&REST"), Qreal),
    Qreal );

  // 1+ (function (number) number)
  add_ftype(Q("1+"),
    list(Qnumber),
    Qnumber );

  // count (function (t sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function) (:test test-2-function) (:test-not test-2-function)) sequence-index)
  add_ftype(Q("COUNT"),
    cons(t, cons(Qsequence, cons(Q("&KEY"), list(list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION")))))),
    Q("SEQUENCE-INDEX") );

  // atan (function (number &optional number) number)
  add_ftype(Q("ATAN"),
    list(Qnumber, Q("&OPTIONAL"), Qnumber),
    Qnumber );

  // listp (function (t) t)
  add_ftype(Q("LISTP"),
    list(t),
    t );

  // close (function (stream &key (:abort t)) t)
  add_ftype(Q("CLOSE"),
    list(Qstream, Q("&KEY"), list(Q(":ABORT"), t)),
    t );

  // signum (function (number) number)
  add_ftype(Q("SIGNUM"),
    list(Qnumber),
    Qnumber );

  // boole (function (t integer integer) integer)
  add_ftype(Q("BOOLE"),
    list(t, Qinteger, Qinteger),
    Qinteger );

  // mod (function (real real) real)
  add_ftype(Q("MOD"),
    list(Qreal, Qreal),
    Qreal );

  // isqrt (function (unsigned-byte) unsigned-byte)
  add_ftype(Q("ISQRT"),
    list(Q("UNSIGNED-BYTE")),
    Q("UNSIGNED-BYTE") );

  // copy-readtable (function (&optional (or readtable null) (or readtable null)) readtable)
  add_ftype(Q("COPY-READTABLE"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qreadtable, Qnull), list(Q("OR"), Qreadtable, Qnull)),
    Qreadtable );

  // read-from-string (function (string &optional t t &key (:start sequence-index) (:end sequence-end) (:preserve-whitespace t)) (values t sequence-index))
  add_ftype(Q("READ-FROM-STRING"),
    cons(Qstring, cons(Q("&OPTIONAL"), list(t, t, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":PRESERVE-WHITESPACE"), t)))),
    list(Q("VALUES"), t, Q("SEQUENCE-INDEX")) );

  // cadr (function (list) t)
  add_ftype(Q("CADR"),
    list(Qlist),
    t );

  // (setf cadr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CADR")),
    list(t, Qcons),
    t );

  // cddr (function (list) t)
  add_ftype(Q("CDDR"),
    list(Qlist),
    t );

  // (setf cddr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDDR")),
    list(t, Qcons),
    t );

  // macro-function (function (function-name &optional t) (or function null))
  add_ftype(Q("MACRO-FUNCTION"),
    list(Q("FUNCTION-NAME"), Q("&OPTIONAL"), t),
    list(Q("OR"), Qfunction, Qnull) );

  // (setf macro-function) (function ((or function null) function-name &optional t) (or function null))
  add_ftype(intern_setf_cell(Q("MACRO-FUNCTION")),
    list(list(Q("OR"), Qfunction, Qnull), Q("FUNCTION-NAME"), Q("&OPTIONAL"), t),
    list(Q("OR"), Qfunction, Qnull) );

  // butlast (function (list &optional sequence-index) list)
  add_ftype(Q("BUTLAST"),
    list(Qlist, Q("&OPTIONAL"), Q("SEQUENCE-INDEX")),
    Qlist );

  // remove-if-not (function (test-1-function sequence &key (:count (or integer null)) (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) sequence)
  add_ftype(Q("REMOVE-IF-NOT"),
    cons(Q("TEST-1-FUNCTION"), cons(Qsequence, list(Q("&KEY"), list(Q(":COUNT"), list(Q("OR"), Qinteger, Qnull)), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION"))))),
    Qsequence );

  // make-random-state (function (&optional (or random-state null (eql t))) random-state)
  add_ftype(Q("MAKE-RANDOM-STATE"),
    list(Q("&OPTIONAL"), list(Q("OR"), Q("RANDOM-STATE"), Qnull, list(Q("EQL"), t))),
    Q("RANDOM-STATE") );

  // <= (function (real &rest real) t)
  add_ftype(Q("<="),
    list(Qreal, Q("&REST"), Qreal),
    t );

  // identity (function (t) t)
  add_ftype(Q("IDENTITY"),
    list(t),
    t );

  // hash-table-rehash-size (function (hash-table) (or (integer 1 *) (single-float (1) *)))
  add_ftype(Q("HASH-TABLE-REHASH-SIZE"),
    list(Qhash_table),
    list(Q("OR"), list(Qinteger, Fixnum::Encode(1), Q("*")), list(Qsingle_float, list(Fixnum::Encode(1)), Q("*"))) );

  // reduce (function (function-designator sequence &key (:key key-function) (:from-end t) (:start sequence-index) (:end sequence-end)) t)
  add_ftype(Q("REDUCE"),
    cons(Q("FUNCTION-DESIGNATOR"), list(Qsequence, Q("&KEY"),
        list(Q(":KEY"), Q("KEY-FUNCTION")),
        list(Q(":FROM-END"), t),
        list(Q(":INITIAL-VALUE"), t),
        list(Q(":START"), Q("SEQUENCE-INDEX")),
        list(Q(":END"), Q("SEQUENCE-END")))),
    t );

  // vector-push-extend (function (t vector &optional (integer 1)) sequence-index)
  add_ftype(Q("VECTOR-PUSH-EXTEND"),
    list(t, Qvector, Q("&OPTIONAL"), list(Qinteger, Fixnum::Encode(1))),
    Q("SEQUENCE-INDEX") );

  // make-string (function (sequence-index &key (:initial-element character) (:element-type type-specifier)) simple-string)
  add_ftype(Q("MAKE-STRING"),
    list(Q("SEQUENCE-INDEX"), Q("&KEY"), list(Q(":INITIAL-ELEMENT"), Qcharacter), list(Q(":ELEMENT-TYPE"), Q("TYPE-SPECIFIER"))),
    Qsimple_string );

  // arrayp (function (t) t)
  add_ftype(Q("ARRAYP"),
    list(t),
    t );

  // replace (function (sequence sequence &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) sequence)
  add_ftype(Q("REPLACE"),
    cons(Qsequence, list(Qsequence, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    Qsequence );

  // subst-if (function (t predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("SUBST-IF"),
    list(t, Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // read-char (function (&optional (or stream (member nil t)) t t t) t)
  add_ftype(Q("READ-CHAR"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t)), t, t, t),
    t );

  // get-properties (function (list list) (values t t list))
  add_ftype(Q("GET-PROPERTIES"),
    list(Qlist, Qlist),
    list(Q("VALUES"), t, t, Qlist) );

  // unexport (function ((or list symbol) &optional package-designator) (eql t))
  add_ftype(Q("UNEXPORT"),
    list(list(Q("OR"), Qlist, Qsymbol), Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // makunbound (function (symbol) symbol)
  add_ftype(Q("MAKUNBOUND"),
    list(Qsymbol),
    Qsymbol );

  // read (function (&optional stream-designator t t t) t)
  add_ftype(Q("READ"),
    list(Q("&OPTIONAL"), Q("STREAM-DESIGNATOR"), t, t, t),
    t );

  // read-delimited-list (function (character &optional stream-designator t) list)
  add_ftype(Q("READ-DELIMITED-LIST"),
    list(Qcharacter, Q("&OPTIONAL"), Q("STREAM-DESIGNATOR"), t),
    Qlist );

  // short-site-name (function nil simple-string)
  add_ftype(Q("SHORT-SITE-NAME"),
    nil,
    Qsimple_string );

  // nsubstitute-if (function (t test-2-function sequence &key (:start sequence-index) (:end sequence-end) (:from-end t) (:key key-function) (:count sequence-end)) sequence)
  add_ftype(Q("NSUBSTITUTE-IF"),
    cons(t, cons(Q("TEST-2-FUNCTION"), cons(Qsequence, list(Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":COUNT"), Q("SEQUENCE-END")))))),
    Qsequence );

  // simple-condition-format-control (function (format-control) list)
  add_ftype(Q("SIMPLE-CONDITION-FORMAT-CONTROL"),
    list(Q("SIMPLE-CONDITION")),
    Q("FORMAT-CONTROL") );

  // disassemble (function (t) null)
  add_ftype(Q("DISASSEMBLE"),
    list(t),
    Qnull );

  // fill-pointer (function (vector) sequence-index)
  add_ftype(Q("FILL-POINTER"),
    list(Qvector),
    Q("SEQUENCE-INDEX") );

  // (setf fill-pointer) (function (sequence-index vector) sequence-index)
  add_ftype(intern_setf_cell(Q("FILL-POINTER")),
    list(Q("SEQUENCE-INDEX"), Qvector),
    Q("SEQUENCE-INDEX") );

  // sublis (function (t list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("SUBLIS"),
    list(t, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // delete-duplicates (function (sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function) (:test test-2-function) (:test-not test-2-function)) sequence)
  add_ftype(Q("DELETE-DUPLICATES"),
    cons(Qsequence, cons(Q("&KEY"), list(list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))))),
    Qsequence );

  // apropos (function (string &optional (or package-designator null)) (values))
  add_ftype(Q("APROPOS"),
    list(Qstring, Q("&OPTIONAL"), list(Q("OR"), Q("PACKAGE-DESIGNATOR"), Qnull)),
    list(Q("VALUES")) );

  // write-line (function (string &optional (or stream (member nil t)) &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("WRITE-LINE"),
    list(Qstring, Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t)), Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // numberp (function (t) t)
  add_ftype(Q("NUMBERP"),
    list(t),
    t );

  // simple-string-p (function (t) t)
  add_ftype(Q("SIMPLE-STRING-P"),
    list(t),
    t );

  // file-namestring (function (pathname-designator) string)
  add_ftype(Q("FILE-NAMESTRING"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qstring );

  // min (function (real &rest real) real)
  add_ftype(Q("MIN"),
    list(Qreal, Q("&REST"), Qreal),
    Qreal );

  // sin (function (number) number)
  add_ftype(Q("SIN"),
    list(Qnumber),
    Qnumber );

  // float-digits (function (float) integer)
  add_ftype(Q("FLOAT-DIGITS"),
    list(Qfloat),
    Qinteger );

  // function-keywords (function (standard-method) (values list t))
  add_ftype(Q("FUNCTION-KEYWORDS"),
    list(Qstandard_method),
    list(Q("VALUES"), Qlist, t) );

  // length (function (sequence) sequence-index)
  add_ftype(Q("LENGTH"),
    list(Qsequence),
    Q("SEQUENCE-INDEX") );

  // bit-vector-p (function (t) t)
  add_ftype(Q("BIT-VECTOR-P"),
    list(t),
    t );

  // car (function (list) t)
  add_ftype(Q("CAR"),
    list(Qlist),
    t );

  // (setf car) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAR")),
    list(t, Qcons),
    t );

  // aref (function (array &rest sequence-index) t)
  add_ftype(Q("AREF"),
    list(Qarray, Q("&REST"), Q("SEQUENCE-INDEX")),
    t );

  // (setf aref) (function (t array &rest sequence-index) t)
  add_ftype(intern_setf_cell(Q("AREF")),
    list(t, Qarray, Q("&REST"), Q("SEQUENCE-INDEX")),
    t );

  // constantp (function (t &optional t) t)
  add_ftype(Q("CONSTANTP"),
    list(t, Q("&OPTIONAL"), t),
    t );

  // make-list (function (sequence-index &key (:initial-element t)) list)
  add_ftype(Q("MAKE-LIST"),
    list(Q("SEQUENCE-INDEX"), Q("&KEY"), list(Q(":INITIAL-ELEMENT"), t)),
    Qlist );

  // method-qualifiers (function (method) list)
  add_ftype(Q("METHOD-QUALIFIERS"),
    list(Qmethod),
    Qlist );

  // unread-char (function (character &optional (or stream (member nil t))) null)
  add_ftype(Q("UNREAD-CHAR"),
    list(Qcharacter, Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t))),
    Qnull );

  // character (function (character-designator) character)
  add_ftype(Qcharacter,
    list(Q("CHARACTER-DESIGNATOR")),
    Qcharacter );

  // position-if (function (test-1-function sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) (or sequence-index null))
  add_ftype(Q("POSITION-IF"),
    cons(Q("TEST-1-FUNCTION"), list(Qsequence, Q("&KEY"), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // bit-ior (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-IOR"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // eval (function (t) (values &rest t))
  add_ftype(Q("EVAL"),
    list(t),
    list(Q("VALUES"), Q("&REST"), t) );

  // char-code (function (character) unsigned-byte)
  add_ftype(Q("CHAR-CODE"),
    list(Qcharacter),
    Q("CHARACTER-CODE") );

  // require (function (string-designator &optional list) t)
  add_ftype(Q("REQUIRE"),
    list(Q("STRING-DESIGNATOR"), Q("&OPTIONAL"), Qlist),
    t );

  // string<= (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING<="),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // bit-nor (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-NOR"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // clrhash (function (hash-table) hash-table)
  add_ftype(Q("CLRHASH"),
    list(Qhash_table),
    Qhash_table );

  // complement (function (function) function)
  add_ftype(Q("COMPLEMENT"),
    list(Qfunction),
    Qfunction );

  // float (function (real &optional float) float)
  add_ftype(Qfloat,
    list(Qreal, Q("&OPTIONAL"), Qfloat),
    Qfloat );

  // make-symbol (function (string) symbol)
  add_ftype(Q("MAKE-SYMBOL"),
    list(Qstring),
    Qsymbol );

  // hash-table-rehash-threshold (function (hash-table) (real 0 1))
  add_ftype(Q("HASH-TABLE-REHASH-THRESHOLD"),
    list(Qhash_table),
    list(Qreal, Fixnum::Encode(0), Fixnum::Encode(1)) );

  // member (function (t list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("MEMBER"),
    list(t, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // bit-xor (function ((array bit) (array bit) &optional (or (array bit) null (eql t))) (array bit))
  add_ftype(Q("BIT-XOR"),
    list(list(Qarray, Q("BIT")), list(Qarray, Q("BIT")), Q("&OPTIONAL"), list(Q("OR"), list(Qarray, Q("BIT")), Qnull, list(Q("EQL"), t))),
    list(Qarray, Q("BIT")) );

  // nintersection (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("NINTERSECTION"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // notevery (function (function sequence &rest sequence) t)
  add_ftype(Q("NOTEVERY"),
    list(Qfunction, Qsequence, Q("&REST"), Qsequence),
    t );

  // subsetp (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) t)
  add_ftype(Q("SUBSETP"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    t );

  // ffloor (function (real &optional real) (values float real))
  add_ftype(Q("FFLOOR"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qfloat, Qreal) );

  // rassoc-if (function (predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("RASSOC-IF"),
    list(Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // use-value (function (&optional (or condition null)) null)
  add_ftype(Q("USE-VALUE"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qcondition, Qnull)),
    Qnull );

  // read-line (function (&optional (or stream (member nil t)) t t t) (values t t))
  add_ftype(Q("READ-LINE"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t)), t, t, t),
    list(Q("VALUES"), t, t) );

  // shadowing-import (function ((or list symbol) &optional package-designator) (eql t))
  add_ftype(Q("SHADOWING-IMPORT"),
    list(list(Q("OR"), Qlist, Qsymbol), Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // logorc2 (function (integer integer) integer)
  add_ftype(Q("LOGORC2"),
    list(Qinteger, Qinteger),
    Qinteger );

  // oddp (function (integer) t)
  add_ftype(Q("ODDP"),
    list(Qinteger),
    t );

  // set-syntax-from-char (function (character character &optional readtable-designator) (eql t))
  add_ftype(Q("SET-SYNTAX-FROM-CHAR"),
    list(Qcharacter, Qcharacter, Q("&OPTIONAL"), Q("READTABLE-DESIGNATOR")),
    list(Q("EQL"), t) );

  // machine-version (function nil simple-string)
  add_ftype(Q("MACHINE-VERSION"),
    nil,
    Qsimple_string );

  // make-sequence (function (type-specifier unsigned-byte &key (:initial-element t)) sequence)
  add_ftype(Q("MAKE-SEQUENCE"),
    list(Q("TYPE-SPECIFIER"), Q("UNSIGNED-BYTE"), Q("&KEY"), list(Q(":INITIAL-ELEMENT"), t)),
    Qsequence );

  // gcd (function (&rest integer) integer)
  add_ftype(Q("GCD"),
    list(Q("&REST"), Qinteger),
    Qinteger );

  // long-site-name (function nil simple-string)
  add_ftype(Q("LONG-SITE-NAME"),
    nil,
    Qsimple_string );

  // name-char (function (string-designator) (or character null))
  add_ftype(Q("NAME-CHAR"),
    list(Q("STRING-DESIGNATOR")),
    list(Q("OR"), Qcharacter, Qnull) );

  // slot-makunbound (function (t symbol) t)
  add_ftype(Q("SLOT-MAKUNBOUND"),
    list(t, Qsymbol),
    t );

  // mask-field (function (bytespec integer) unsigned-byte)
  add_ftype(Q("MASK-FIELD"),
    list(Q("BYTESPEC"), Qinteger),
    Q("UNSIGNED-BYTE") );

  // make-condition (function (type-specifier &key &allow-other-keys) condition)
  add_ftype(Q("MAKE-CONDITION"),
    list(Q("TYPE-SPECIFIER"), Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    Qcondition );

  // subtypep (function (type-specifier type-specifier &optional t) (values t t))
  add_ftype(Q("SUBTYPEP"),
    list(Q("TYPE-SPECIFIER"), Q("TYPE-SPECIFIER"), Q("&OPTIONAL"), t),
    list(Q("VALUES"), t, t) );

  // asinh (function (number) number)
  add_ftype(Q("ASINH"),
    list(Qnumber),
    Qnumber );

  // equal (function (t t) t)
  add_ftype(Q("EQUAL"),
    list(t, t),
    t );

  // gethash (function (t hash-table &optional t) (values t t))
  add_ftype(Q("GETHASH"),
    list(t, Qhash_table, Q("&OPTIONAL"), t),
    list(Q("VALUES"), t, t) );

  // (setf gethash) (function (t t hash-table &optional t) t)
  add_ftype(intern_setf_cell(Q("GETHASH")),
    list(t, t, Qhash_table, Q("&OPTIONAL"), t),
    t );

  // lognand (function (integer integer) integer)
  add_ftype(Q("LOGNAND"),
    list(Qinteger, Qinteger),
    Qinteger );

  // phase (function (number) number)
  add_ftype(Q("PHASE"),
    list(Qnumber),
    Qnumber );

  // find-if-not (function (test-1-function sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) t)
  add_ftype(Q("FIND-IF-NOT"),
    cons(Q("TEST-1-FUNCTION"), list(Qsequence, Q("&KEY"), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")))),
    t );

  // array-has-fill-pointer-p (function (vector) t)
  add_ftype(Q("ARRAY-HAS-FILL-POINTER-P"),
    list(Qvector),
    t );

  // fround (function (real &optional real) (values float real))
  add_ftype(Q("FROUND"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qfloat, Qreal) );

  // list* (function (t &rest t) t)
  add_ftype(Q("LIST*"),
    list(t, Q("&REST"), t),
    t );

  // floor (function (real &optional real) (values integer real))
  add_ftype(Q("FLOOR"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qinteger, Qreal) );

  // string-trim (function (sequence string-designator) string)
  add_ftype(Q("STRING-TRIM"),
    list(Qsequence, Q("STRING-DESIGNATOR")),
    Qstring );

  // input-stream-p (function (stream) t)
  add_ftype(Q("INPUT-STREAM-P"),
    list(Qstream),
    t );

  // caaadr (function (list) t)
  add_ftype(Q("CAAADR"),
    list(Qlist),
    t );

  // (setf caaadr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAAADR")),
    list(t, Qcons),
    t );

  // cdaaar (function (list) t)
  add_ftype(Q("CDAAAR"),
    list(Qlist),
    t );

  // (setf cdaaar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDAAAR")),
    list(t, Qcons),
    t );

  // caaddr (function (list) t)
  add_ftype(Q("CAADDR"),
    list(Qlist),
    t );

  // (setf caaddr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAADDR")),
    list(t, Qcons),
    t );

  // cdadar (function (list) t)
  add_ftype(Q("CDADAR"),
    list(Qlist),
    t );

  // (setf cdadar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDADAR")),
    list(t, Qcons),
    t );

  // >= (function (real &rest real) t)
  add_ftype(Q(">="),
    list(Qreal, Q("&REST"), Qreal),
    t );

  // assoc-if (function (predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("ASSOC-IF"),
    list(Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // find-symbol (function (string &optional package-designator) (values symbol (member :inherited :external :internal nil)))
  add_ftype(Q("FIND-SYMBOL"),
    list(Qstring, Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("VALUES"), Qsymbol, list(Q("MEMBER"), Q(":INHERITED"), Q(":EXTERNAL"), Q(":INTERNAL"), nil)) );

  // imagpart (function (number) real)
  add_ftype(Q("IMAGPART"),
    list(Qnumber),
    Qreal );

  // char/= (function (&rest character) t)
  add_ftype(Q("CHAR/="),
    list(Q("&REST"), Qcharacter),
    t );

  // cerror (function (format-control condition-designator &rest t) null)
  add_ftype(Q("CERROR"),
    list(Q("FORMAT-CONTROL"), Q("CONDITION-DESIGNATOR"), Q("&REST"), t),
    Qnull );

  // write-to-string (function (string &optional (or stream (member nil t)) &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("WRITE-TO-STRING"),
    list(Qstring, Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t)), Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // make-string-output-stream (function (&key (:element-type type-specifier)) string-output-stream)
  add_ftype(Q("MAKE-STRING-OUTPUT-STREAM"),
    list(Q("&KEY"), list(Q(":ELEMENT-TYPE"), Q("TYPE-SPECIFIER"))),
    Qstring_output_stream );

  // char-not-lessp (function (&rest character) t)
  add_ftype(Q("CHAR-NOT-LESSP"),
    list(Q("&REST"), Qcharacter),
    t );

  // open (function (pathname-designator &key (:direction (member :input :output :io :probe)) (:element-type type-specifier) (:if-exists (member :error :new-version :rename :rename-or-delete :overwrite :supersede nil)) (:if-does-not-exist (member :error :create nil)) (:external-format type-specifier)) stream)
  add_ftype(Q("OPEN"),
    cons(Q("PATHNAME-DESIGNATOR"), list(Q("&KEY"), list(Q(":DIRECTION"), list(Q("MEMBER"), Q(":INPUT"), Q(":OUTPUT"), Q(":IO"), Q(":PROBE"))), list(Q(":ELEMENT-TYPE"), Q("TYPE-SPECIFIER")), list(Q(":IF-EXISTS"), cons(Q("MEMBER"), cons(Q(":ERROR"), list(Q(":NEW-VERSION"), Q(":RENAME"), Q(":RENAME-OR-DELETE"), Q(":OVERWRITE"), Q(":SUPERSEDE"), nil)))), list(Q(":IF-DOES-NOT-EXIST"), list(Q("MEMBER"), Q(":ERROR"), Q(":CREATE"), nil)), list(Q(":EXTERNAL-FORMAT"), Q("TYPE-SPECIFIER")))),
    Qstream );

  // round (function (real &optional real) (values integer real))
  add_ftype(Q("ROUND"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qinteger, Qreal) );

  // eq (function (t t) t)
  add_ftype(Q("EQ"),
    list(t, t),
    t );

  // update-instance-for-different-class (function (t t &key &allow-other-keys) t)
  add_ftype(Q("UPDATE-INSTANCE-FOR-DIFFERENT-CLASS"),
    list(t, t, Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // logeqv (function (&rest integer) integer)
  add_ftype(Q("LOGEQV"),
    list(Q("&REST"), Qinteger),
    Qinteger );

  // nsubstitute-if-not (function (t test-2-function sequence &key (:start sequence-index) (:end sequence-end) (:from-end t) (:key key-function) (:count sequence-end)) sequence)
  add_ftype(Q("NSUBSTITUTE-IF-NOT"),
    cons(t, cons(Q("TEST-2-FUNCTION"), cons(Qsequence, list(Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":COUNT"), Q("SEQUENCE-END")))))),
    Qsequence );

  // pathname-version (function (pathname) (or unsigned-byte (member :wild :newest :unspecific)))
  add_ftype(Q("PATHNAME-VERSION"),
    list(Q("PATHNAME-DESIGNATOR")),
    list(Q("OR"), Q("UNSIGNED-BYTE"), list(Q("MEMBER"), Q(":WILD"), Q(":NEWEST"), Q(":UNSPECIFIC"))) );

  // stable-sort (function (sequence test-2-function &key (:key key-function)) sequence)
  add_ftype(Q("STABLE-SORT"),
    list(Qsequence, Q("TEST-2-FUNCTION"), Q("&KEY"), list(Q(":KEY"), Q("KEY-FUNCTION"))),
    Qsequence );

  // - (function (number &rest number) number)
  add_ftype(Q("-"),
    list(Qnumber, Q("&REST"), Qnumber),
    Qnumber );

  // error (function (condition-designator &rest t) nil)
  add_ftype(Qerror,
    list(Q("CONDITION-DESIGNATOR"), Q("&REST"), t),
    nil );

  // inspect (function (t) t)
  add_ftype(Q("INSPECT"),
    list(t),
    t );

  // delete-file (function (pathname-designator) (eql t))
  add_ftype(Q("DELETE-FILE"),
    list(Q("PATHNAME-DESIGNATOR")),
    list(Q("EQL"), t) );

  // merge (function (type-specifier sequence sequence test-2-function &key (:key key-function)) sequence)
  add_ftype(Q("MERGE"),
    list(Q("TYPE-SPECIFIER"), Qsequence, Qsequence, Q("TEST-2-FUNCTION"), Q("&KEY"), list(Q(":KEY"), Q("KEY-FUNCTION"))),
    Qsequence );

  // package-nicknames (function (package-designator) list)
  add_ftype(Q("PACKAGE-NICKNAMES"),
    list(Q("PACKAGE-DESIGNATOR")),
    Qlist );

  // string< (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING<"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // make-package (function (string-designator &key (:size sequence-index) (:nicknames (or string list)) (:use (or package-designator list))) package)
  add_ftype(Q("MAKE-PACKAGE"),
    list(Q("STRING-DESIGNATOR"), Q("&KEY"), list(Q(":SIZE"), Q("SEQUENCE-END")), list(Q(":NICKNAMES"), list(Q("OR"), Qstring, Qlist)), list(Q(":USE"), list(Q("OR"), Q("PACKAGE-DESIGNATOR"), Qlist))),
    Qpackage );

  // hash-table-p (function (t) t)
  add_ftype(Q("HASH-TABLE-P"),
    list(t),
    t );

  // readtable-case (function (readtable) case-sensitivity-mode)
  add_ftype(Q("READTABLE-CASE"),
    list(Qreadtable),
    Q("CASE-SENSITIVITY-MODE") );

  // (setf readtable-case) (function (case-sensitivity-mode readtable) case-sensitivity-mode)
  add_ftype(intern_setf_cell(Q("READTABLE-CASE")),
    list(Q("CASE-SENSITIVITY-MODE"), Qreadtable),
    Q("CASE-SENSITIVITY-MODE") );

  // substitute-if (function (t test-2-function sequence &key (:start sequence-index) (:end sequence-end) (:from-end t) (:key key-function) (:count sequence-end)) sequence)
  add_ftype(Q("SUBSTITUTE-IF"),
    cons(t, cons(Q("TEST-2-FUNCTION"), cons(Qsequence, list(Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":COUNT"), Q("SEQUENCE-END")))))),
    Qsequence );

  // wild-pathname-p (function (pathname-designator &optional (member :host :device :directgory :name :type :version nil)) t)
  add_ftype(Q("WILD-PATHNAME-P"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&OPTIONAL"), cons(Q("MEMBER"), cons(Q(":HOST"), list(Q(":DEVICE"), Q(":DIRECTGORY"), Q(":NAME"), Q(":TYPE"), Q(":VERSION"), nil)))),
    t );

  // get-output-stream-string (function (string-output-stream) string)
  add_ftype(Q("GET-OUTPUT-STREAM-STRING"),
    list(Qstring_output_stream),
    Qstring );

  // char-greaterp (function (&rest character) t)
  add_ftype(Q("CHAR-GREATERP"),
    list(Q("&REST"), Qcharacter),
    t );

  // search (function (sequence sequence &key (:key key-function) (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end) (:from-end t) (:test test-2-function) (:test-no test-2-function)) (or sequence-index null))
  add_ftype(Q("SEARCH"),
    cons(Qsequence, cons(Qsequence, cons(Q("&KEY"), cons(list(Q(":KEY"), Q("KEY-FUNCTION")), cons(list(Q(":START1"), Q("SEQUENCE-INDEX")), list(list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NO"), Q("TEST-2-FUNCTION")))))))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // princ (function (t &optional stream-designator) (values t))
  add_ftype(Q("PRINC"),
    list(t, Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    list(Q("VALUES"), t) );

  // describe-object (function (t stream) t)
  add_ftype(Q("DESCRIBE-OBJECT"),
    list(t, Qstream),
    t );

  // echo-stream-input-stream (function (echo-stream) stream)
  add_ftype(Q("ECHO-STREAM-INPUT-STREAM"),
    list(Qecho_stream),
    Qstream );

  // directory (function (pathname-designator) list)
  add_ftype(Q("DIRECTORY"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qlist );

  // substitute-if-not (function (t test-2-function sequence &key (:start sequence-index) (:end sequence-end) (:from-end t) (:key key-function) (:count sequence-end)) sequence)
  add_ftype(Q("SUBSTITUTE-IF-NOT"),
    cons(t, cons(Q("TEST-2-FUNCTION"), cons(Qsequence, list(Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":FROM-END"), t), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":COUNT"), Q("SEQUENCE-END")))))),
    Qsequence );

  // warn (function (condition-designator &rest t) null)
  add_ftype(Q("WARN"),
    list(Q("CONDITION-DESIGNATOR"), Q("&REST"), t),
    Qnull );

  // simple-condition-format-arguments (function (simple-condition) list)
  add_ftype(Q("SIMPLE-CONDITION-FORMAT-ARGUMENTS"),
    list(Qsimple_condition),
    Qlist );

  // gentemp (function (&optional string package-designator) symbol)
  add_ftype(Q("GENTEMP"),
    list(Q("&OPTIONAL"), Qstring, Q("PACKAGE-DESIGNATOR")),
    Qsymbol );

  // delete-if-not (function (test-1-function sequence &key (:count (or integer null)) (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function)) sequence)
  add_ftype(Q("DELETE-IF-NOT"),
    cons(Q("TEST-1-FUNCTION"), cons(Qsequence, list(Q("&KEY"), list(Q(":COUNT"), list(Q("OR"), Qinteger, Qnull)), list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION"))))),
    Qsequence );

  // print-not-readable-object (function (print-not-readable) t)
  add_ftype(Q("PRINT-NOT-READABLE-OBJECT"),
    list(Q("PRINT-NOT-READABLE")),
    t );

  // sinh (function (number) number)
  add_ftype(Q("SINH"),
    list(Qnumber),
    Qnumber );

  // graphic-char-p (function (character) t)
  add_ftype(Q("GRAPHIC-CHAR-P"),
    list(Qcharacter),
    t );

  // clear-input (function (&optional stream-designator) null)
  add_ftype(Q("CLEAR-INPUT"),
    list(Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    Qnull );

  // copy-symbol (function (symbol &optional t) symbol)
  add_ftype(Q("COPY-SYMBOL"),
    list(Qsymbol, Q("&OPTIONAL"), t),
    Qsymbol );

  // cos (function (number) number)
  add_ftype(Q("COS"),
    list(Qnumber),
    Qnumber );

  // make-load-form (function (t &optional (or environment null)) (values t &optional t))
  add_ftype(Q("MAKE-LOAD-FORM"),
    list(t, Q("&OPTIONAL"), list(Q("OR"), Qenvironment, Qnull)),
    list(Q("VALUES"), t, Q("&OPTIONAL"), t) );

  // vector-push (function (t vector) (or sequence-index null))
  add_ftype(Q("VECTOR-PUSH"),
    list(t, Qvector),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // delete-package (function (package-designator) t)
  add_ftype(Q("DELETE-PACKAGE"),
    list(Q("PACKAGE-DESIGNATOR")),
    t );

  // nstring-upcase (function (string &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("NSTRING-UPCASE"),
    list(Qstring, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // y-or-n-p (function (&optional format-control &rest t) t)
  add_ftype(Q("Y-OR-N-P"),
    list(Q("&OPTIONAL"), Q("FORMAT-CONTROL"), Q("&REST"), t),
    t );

  // string-greaterp (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING-GREATERP"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // logorc1 (function (integer integer) integer)
  add_ftype(Q("LOGORC1"),
    list(Qinteger, Qinteger),
    Qinteger );

  // restart-name (function (restart) symbol)
  add_ftype(Q("RESTART-NAME"),
    list(Qrestart),
    Qsymbol );

  // dpb (function (integer bytespec integer) integer)
  add_ftype(Q("DPB"),
    list(Qinteger, Q("BYTESPEC"), Qinteger),
    Qinteger );

  // char-int (function (character) unsigned-byte)
  add_ftype(Q("CHAR-INT"),
    list(Qcharacter),
    Q("CHARACTER-CODE") );

  // denominator (function (rational) integer)
  add_ftype(Q("DENOMINATOR"),
    list(Qrational),
    Qinteger );

  // nsubst-if-not (function (t predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("NSUBST-IF-NOT"),
    list(t, Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // hash-table-count (function (hash-table) sequence-index)
  add_ftype(Q("HASH-TABLE-COUNT"),
    list(Qhash_table),
    Q("SEQUENCE-INDEX") );

  // concatenated-stream-streams (function (concatenated-stream) list)
  add_ftype(Q("CONCATENATED-STREAM-STREAMS"),
    list(Qconcatenated_stream),
    Qlist );

  // pathname-directory (function (pathname &key (:case (member :local :common))) (or string list null (member :wild :wild-inferior :unspecific)))
  add_ftype(Q("PATHNAME-DIRECTORY"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":CASE"), list(Q("MEMBER"), Q(":LOCAL"), Q(":COMMON")))),
    list(Q("OR"), Qstring, Qlist, Qnull, list(Q("MEMBER"), Q(":WILD"), Q(":WILD-INFERIOR"), Q(":UNSPECIFIC"))) );

  // make-dispatch-macro-character (function (character &optional t readtable) (eql t))
  add_ftype(Q("MAKE-DISPATCH-MACRO-CHARACTER"),
    list(Qcharacter, Q("&OPTIONAL"), t, Qreadtable),
    list(Q("EQL"), t) );

  // apply (function (function-designator &rest t) (values &rest t))
  add_ftype(Q("APPLY"),
    list(Q("FUNCTION-DESIGNATOR"), Q("&REST"), t),
    list(Q("VALUES"), Q("&REST"), t) );

  // atanh (function (number) number)
  add_ftype(Q("ATANH"),
    list(Qnumber),
    Qnumber );

  // pprint-fill (function (stream t &optional t t) (values null))
  add_ftype(Q("PPRINT-FILL"),
    list(Qstream, t, Q("&OPTIONAL"), t, t),
    list(Q("VALUES"), Qnull) );

  // nstring-capitalize (function (string &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("NSTRING-CAPITALIZE"),
    list(Qstring, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // symbol-value (function (symbol) t)
  add_ftype(Q("SYMBOL-VALUE"),
    list(Qsymbol),
    t );

  // (setf symbol-value) (function (t symbol) t)
  add_ftype(intern_setf_cell(Q("SYMBOL-VALUE")),
    list(t, Qsymbol),
    t );

  // fourth (function (list) t)
  add_ftype(Q("FOURTH"),
    list(Qlist),
    t );

  // (setf fourth) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("FOURTH")),
    list(t, Qcons),
    t );

  // make-broadcast-stream (function (&rest stream) broadcast-stream)
  add_ftype(Q("MAKE-BROADCAST-STREAM"),
    list(Q("&REST"), Qstream),
    Qbroadcast_stream );

  // caar (function (list) t)
  add_ftype(Q("CAAR"),
    list(Qlist),
    t );

  // (setf caar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAAR")),
    list(t, Qcons),
    t );

  // rplaca (function (cons t) cons)
  add_ftype(Q("RPLACA"),
    list(Qcons, t),
    Qcons );

  // caaaar (function (list) t)
  add_ftype(Q("CAAAAR"),
    list(Qlist),
    t );

  // (setf caaaar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAAAAR")),
    list(t, Qcons),
    t );

  // cdaadr (function (list) t)
  add_ftype(Q("CDAADR"),
    list(Qlist),
    t );

  // (setf cdaadr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDAADR")),
    list(t, Qcons),
    t );

  // cdar (function (list) t)
  add_ftype(Q("CDAR"),
    list(Qlist),
    t );

  // (setf cdar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDAR")),
    list(t, Qcons),
    t );

  // lognot (function (integer) integer)
  add_ftype(Q("LOGNOT"),
    list(Qinteger),
    Qinteger );

  // prin1-to-string (function (t) string)
  add_ftype(Q("PRIN1-TO-STRING"),
    list(t),
    Qstring );

  // caadar (function (list) t)
  add_ftype(Q("CAADAR"),
    list(Qlist),
    t );

  // (setf caadar) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAADAR")),
    list(t, Qcons),
    t );

  // cdaddr (function (list) t)
  add_ftype(Q("CDADDR"),
    list(Qlist),
    t );

  // (setf cdaddr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CDADDR")),
    list(t, Qcons),
    t );

  // char (function (string sequence-index) character)
  add_ftype(Q("CHAR"),
    list(Qstring, Q("SEQUENCE-INDEX")),
    Qcharacter );

  // (setf char) (function (string sequence-index) character)
  add_ftype(intern_setf_cell(Q("CHAR")),
    list(Qcharacter, Qstring, Q("SEQUENCE-INDEX")),
    Qcharacter );

  // ceiling (function (real &optional real) (values integer real))
  add_ftype(Q("CEILING"),
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("VALUES"), Qinteger, Qreal) );

  // pathnamep (function (t) t)
  add_ftype(Q("PATHNAMEP"),
    list(t),
    t );

  // read-sequence (function (sequence stream &key (:start sequence-index) (:end sequence-end)) sequence-index)
  add_ftype(Q("READ-SEQUENCE"),
    list(Qsequence, Qstream, Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Q("SEQUENCE-INDEX") );

  // remove-duplicates (function (sequence &key (:from-end t) (:start sequence-index) (:end sequence-end) (:key key-function) (:test test-2-function) (:test-not test-2-function)) sequence)
  add_ftype(Q("REMOVE-DUPLICATES"),
    cons(Qsequence, cons(Q("&KEY"), list(list(Q(":FROM-END"), t), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END")), list(Q(":KEY"), Q("KEY-FUNCTION")), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))))),
    Qsequence );

  // 1- (function (number) number)
  add_ftype(Q("1-"),
    list(Qnumber),
    Qnumber );

  // sleep (function ((real 0 *)) null)
  add_ftype(Q("SLEEP"),
    list(list(Qreal, Fixnum::Encode(0), Q("*"))),
    Qnull );

  // broadcast-stream-streams (function (broadcast-stream) list)
  add_ftype(Q("BROADCAST-STREAM-STREAMS"),
    list(Qbroadcast_stream),
    Qlist );

  // symbol-plist (function (symbol) list)
  add_ftype(Q("SYMBOL-PLIST"),
    list(Qsymbol),
    Qlist );

  // (setf symbol-plist) (function (list symbol) list)
  add_ftype(intern_setf_cell(Q("SYMBOL-PLIST")),
    list(Qlist, Qsymbol),
    Qlist );

  // compute-applicable-methods (function (generic-function list) list)
  add_ftype(Q("COMPUTE-APPLICABLE-METHODS"),
    list(Qgeneric_function, Qlist),
    Qlist );

  // pprint-indent (function ((member :block :current) real &optional stream) (values null))
  add_ftype(Q("PPRINT-INDENT"),
    list(list(Q("MEMBER"), Q(":BLOCK"), Q(":CURRENT")), Qreal, Q("&OPTIONAL"), Qstream),
    list(Q("VALUES"), Qnull) );

  // pathname-type (function (pathname &key (:case (member :local :common))) (or string null (member :wild :unspecific)))
  add_ftype(Q("PATHNAME-TYPE"),
    list(Q("PATHNAME-DESIGNATOR"), Q("&KEY"), list(Q(":CASE"), list(Q("MEMBER"), Q(":LOCAL"), Q(":COMMON")))),
    list(Q("OR"), Qstring, Qnull, list(Q("MEMBER"), Q(":WILD"), Q(":UNSPECIFIC"))) );

  // file-string-length (function (stream (or string character)) (or unsigned-byte null))
  add_ftype(Q("FILE-STRING-LENGTH"),
    list(Qstream, list(Q("OR"), Qstring, Qcharacter)),
    list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull) );

  // force-output (function (&optional stream-designator) null)
  add_ftype(Q("FORCE-OUTPUT"),
    list(Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    Qnull );

  // clear-output (function (&optional stream-designator) null)
  add_ftype(Q("CLEAR-OUTPUT"),
    list(Q("&OPTIONAL"), Q("STREAM-DESIGNATOR")),
    Qnull );

  // complex (function (real &optional real) (or rational complex))
  add_ftype(Qcomplex,
    list(Qreal, Q("&OPTIONAL"), Qreal),
    list(Q("OR"), Qrational, Qcomplex) );

  // coerce (function (t type-specifier) t)
  add_ftype(Q("COERCE"),
    list(t, Q("TYPE-SPECIFIER")),
    t );

  // consp (function (t) t)
  add_ftype(Q("CONSP"),
    list(t),
    t );

  // pathname (function ((or pathname string stream)) pathname)
  add_ftype(Qpathname,
    list(Q("PATHNAME-DESIGNATOR")),
    Qpathname );

  // princ-to-string (function (t) string)
  add_ftype(Q("PRINC-TO-STRING"),
    list(t),
    Qstring );

  // eighth (function (list) t)
  add_ftype(Q("EIGHTH"),
    list(Qlist),
    t );

  // (setf eighth) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("EIGHTH")),
    list(t, Qcons),
    t );

  // upgraded-complex-part-type (function (type-specifier &optional t) type-specifier)
  add_ftype(Q("UPGRADED-COMPLEX-PART-TYPE"),
    list(Q("TYPE-SPECIFIER"), Q("&OPTIONAL"), t),
    Q("TYPE-SPECIFIER") );

  // string-capitalize (function (string &key (:start sequence-index) (:end sequence-end)) string)
  add_ftype(Q("STRING-CAPITALIZE"),
    list(Q("STRING-DESIGNATOR"), Q("&KEY"), list(Q(":START"), Q("SEQUENCE-INDEX")), list(Q(":END"), Q("SEQUENCE-END"))),
    Qstring );

  // change-class (function (t class-designator &key &allow-other-keys) t)
  add_ftype(Q("CHANGE-CLASS"),
    list(t, Q("CLASS-DESIGNATOR"), Q("&KEY"), Q("&ALLOW-OTHER-KEYS")),
    t );

  // read-char-no-hang (function (&optional (or stream (member nil t)) t t t) t)
  add_ftype(Q("READ-CHAR-NO-HANG"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t)), t, t, t),
    t );

  // compiled-function-p (function (t) t)
  add_ftype(Q("COMPILED-FUNCTION-P"),
    list(t),
    t );

  // string-not-equal (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING-NOT-EQUAL"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // file-error-pathname (function (file-error) pathname-designator)
  add_ftype(Q("FILE-ERROR-PATHNAME"),
    list(Qfile_error),
    Q("PATHNAME-DESIGNATOR") );

  // array-rank (function (array) sequence-index)
  add_ftype(Q("ARRAY-RANK"),
    list(Qarray),
    Q("SEQUENCE-INDEX") );

  // subst-if-not (function (t predicate list &key (:key (or key-function null))) t)
  add_ftype(Q("SUBST-IF-NOT"),
    list(t, Q("PREDICATE"), Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull))),
    t );

  // alpha-char-p (function (character) t)
  add_ftype(Q("ALPHA-CHAR-P"),
    list(Qcharacter),
    t );

  // find-all-symbols (function (string-designator) list)
  add_ftype(Q("FIND-ALL-SYMBOLS"),
    list(Q("STRING-DESIGNATOR")),
    Qlist );

  // logical-pathname-translations (function (logical-host-designator) list)
  add_ftype(Q("LOGICAL-PATHNAME-TRANSLATIONS"),
    list(Q("LOGICAL-HOST-DESIGNATOR")),
    Qlist );

  // (setf logical-pathname-translations) (function (list logical-host-designator) list)
  add_ftype(intern_setf_cell(Q("LOGICAL-PATHNAME-TRANSLATIONS")),
    list(Qlist, Q("LOGICAL-HOST-DESIGNATOR")),
    Qlist );

  // nunion (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("NUNION"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // caadr (function (list) t)
  add_ftype(Q("CAADR"),
    list(Qlist),
    t );

  // (setf caadr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CAADR")),
    list(t, Qcons),
    t );

  // ldb-test (function (bytespec integer) t)
  add_ftype(Q("LDB-TEST"),
    list(Q("BYTESPEC"), Qinteger),
    t );

  // caddr (function (list) t)
  add_ftype(Q("CADDR"),
    list(Qlist),
    t );

  // (setf caddr) (function (t cons) t)
  add_ftype(intern_setf_cell(Q("CADDR")),
    list(t, Qcons),
    t );

  // code-char (function (unsigned-byte) (or character null))
  add_ftype(Q("CODE-CHAR"),
    list(Q("CHARACTER-CODE")),
    list(Q("OR"), Qcharacter, Qnull) );

  // digit-char (function (unsigned-byte &optional (integer 2 36)) character)
  add_ftype(Q("DIGIT-CHAR"),
    list(Q("UNSIGNED-BYTE"), Q("&OPTIONAL"), list(Qinteger, Fixnum::Encode(2), Fixnum::Encode(36))),
    Qcharacter );

  // null (function (t) t)
  add_ftype(Qnull,
    list(t),
    t );

  // function-lambda-expression (function (function) (values list t t))
  add_ftype(Q("FUNCTION-LAMBDA-EXPRESSION"),
    list(Qfunction),
    list(Q("VALUES"), Qlist, t, t) );

  // logtest (function (integer integer) t)
  add_ftype(Q("LOGTEST"),
    list(Qinteger, Qinteger),
    t );

  // schar (function (simple-string sequence-index) character)
  add_ftype(Q("SCHAR"),
    list(Qsimple_string, Q("SEQUENCE-INDEX")),
    Qcharacter );

  // (setf schar) (function (character simple-string sequence-index) character)
  add_ftype(intern_setf_cell(Q("SCHAR")),
    list(Qcharacter, Qsimple_string, Q("SEQUENCE-INDEX")),
    Qcharacter );

  // compiler-macro-function (function (function-name &optional t) (or function null))
  add_ftype(Q("COMPILER-MACRO-FUNCTION"),
    list(Q("FUNCTION-NAME"), Q("&OPTIONAL"), t),
    list(Q("OR"), Qfunction, Qnull) );

  // (setf compiler-macro-function) (function ((or function null) function-name &optional t) (or function null))
  add_ftype(intern_setf_cell(Q("COMPILER-MACRO-FUNCTION")),
    list(list(Q("OR"), Qfunction, Qnull), Q("FUNCTION-NAME"), Q("&OPTIONAL"), t),
    list(Q("OR"), Qfunction, Qnull) );

  // string-lessp (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) (or sequence-index null))
  add_ftype(Q("STRING-LESSP"),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // describe (function (t &optional (or stream (eql t) null)) (values))
  add_ftype(Q("DESCRIBE"),
    list(t, Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("EQL"), t), Qnull)),
    list(Q("VALUES")) );

  // eql (function (t t) t)
  add_ftype(Q("EQL"),
    list(t, t),
    t );

  // alphanumericp (function (character) t)
  add_ftype(Q("ALPHANUMERICP"),
    list(Qcharacter),
    t );

  // values-list (function (list) (values &rest t))
  add_ftype(Q("VALUES-LIST"),
    list(Qlist),
    list(Q("VALUES"), Q("&REST"), t) );

  // logcount (function (integer) unsigned-byte)
  add_ftype(Q("LOGCOUNT"),
    list(Qinteger),
    Q("UNSIGNED-BYTE") );

  // continue (function (&optional (or condition null)) null)
  add_ftype(Q("CONTINUE"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qcondition, Qnull)),
    Qnull );

  // string= (function (string string &key (:start1 sequence-index) (:end1 sequence-end) (:start2 sequence-index) (:end2 sequence-end)) t)
  add_ftype(Q("STRING="),
    cons(Qstring, list(Qstring, Q("&KEY"), list(Q(":START1"), Q("SEQUENCE-INDEX")), list(Q(":END1"), Q("SEQUENCE-END")), list(Q(":START2"), Q("SEQUENCE-INDEX")), list(Q(":END2"), Q("SEQUENCE-END")))),
    t );

  // get-internal-real-time (function nil fixnum)
  add_ftype(Q("GET-INTERNAL-REAL-TIME"),
    nil,
    Qfixnum );

  // class-of (function (t) class)
  add_ftype(Q("CLASS-OF"),
    list(t),
    Qclass );

  // format (function ((or null (eql t) stream string) format-control &rest t) (values (or string null)))
  add_ftype(Q("FORMAT"),
    list(list(Q("OR"), Qnull, list(Q("EQL"), t), Qstream, Qstring), Q("FORMAT-CONTROL"), Q("&REST"), t),
    list(Q("VALUES"), list(Q("OR"), Qstring, Qnull)) );

  // file-position (function (stream &optional (or (member :start :end) unsigned-byte)) t)
  add_ftype(Q("FILE-POSITION"),
    list(Qstream, Q("&OPTIONAL"), list(Q("OR"), list(Q("MEMBER"), Q(":START"), Q(":END")), Q("UNSIGNED-BYTE"))),
    t );

  // sbit (function (simple-bit-vector &rest sequence-index) bit)
  add_ftype(Q("SBIT"),
    list(Qsimple_bit_vector, Q("&REST"), Q("SEQUENCE-INDEX")),
    Q("BIT") );

  // (setf sbit) (function (bit (simple-array bit) &rest sequence-index) bit)
  add_ftype(intern_setf_cell(Q("SBIT")),
    list(Q("BIT"), list(Qsimple_array, Q("BIT")), Q("&REST"), Q("SEQUENCE-INDEX")),
    Q("BIT") );

  // fdefinition (function (function-name) function)
  add_ftype(Q("FDEFINITION"),
    list(Q("FUNCTION-NAME")),
    Qfunction );

  // (setf fdefinition) (function (function function-name) function)
  add_ftype(intern_setf_cell(Q("FDEFINITION")),
    list(Qfunction, Q("FUNCTION-NAME")),
    Qfunction );

  // ensure-generic-function (function (function-name &key (:argument-precedence-order list) (:declare list) (:documentation (or string null)) (:environment (or environment null)) (:generic-function-class class) (:lambda-list list) (:method-class class) (:method-combination method-combination)) generic-function)
  add_ftype(Q("ENSURE-GENERIC-FUNCTION"),
    cons(Q("FUNCTION-NAME"), cons(Q("&KEY"), cons(list(Q(":ARGUMENT-PRECEDENCE-ORDER"), Qlist), cons(list(Q(":DECLARE"), Qlist), list(list(Q(":DOCUMENTATION"), list(Q("OR"), Qstring, Qnull)), list(Q(":ENVIRONMENT"), list(Q("OR"), Qenvironment, Qnull)), list(Q(":GENERIC-FUNCTION-CLASS"), Qclass), list(Q(":LAMBDA-LIST"), Qlist), list(Q(":METHOD-CLASS"), Qclass), list(Q(":METHOD-COMBINATION"), Qmethod_combination)))))),
    Qgeneric_function );

  // packagep (function (t) t)
  add_ftype(Q("PACKAGEP"),
    list(t),
    t );

  // set-exclusive-or (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("SET-EXCLUSIVE-OR"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // get-internal-run-time (function nil fixnum)
  add_ftype(Q("GET-INTERNAL-RUN-TIME"),
    nil,
    Qfixnum );

  // load-logical-pathname-translations (function (string) t)
  add_ftype(Q("LOAD-LOGICAL-PATHNAME-TRANSLATIONS"),
    list(Qstring),
    t );

  // union (function (list list &key (:key (or key-function null)) (:test test-2-function) (:test-not test-2-function)) list)
  add_ftype(Q("UNION"),
    list(Qlist, Qlist, Q("&KEY"), list(Q(":KEY"), list(Q("OR"), Q("KEY-FUNCTION"), Qnull)), list(Q(":TEST"), Q("TEST-2-FUNCTION")), list(Q(":TEST-NOT"), Q("TEST-2-FUNCTION"))),
    Qlist );

  // type-of (function (t) type-specifier)
  add_ftype(Q("TYPE-OF"),
    list(t),
    Q("TYPE-SPECIFIER") );

  // logandc1 (function (integer integer) integer)
  add_ftype(Q("LOGANDC1"),
    list(Qinteger, Qinteger),
    Qinteger );

  // symbol-package (function (symbol) (or package null))
  add_ftype(Q("SYMBOL-PACKAGE"),
    list(Qsymbol),
    list(Q("OR"), Qpackage, Qnull) );

  // muffle-warning (function (&optional (or condition null)) nil)
  add_ftype(Q("MUFFLE-WARNING"),
    list(Q("&OPTIONAL"), list(Q("OR"), Qcondition, Qnull)),
    nil );

  // simple-bit-vector-p (function (t) t)
  add_ftype(Q("SIMPLE-BIT-VECTOR-P"),
    list(t),
    t );

  // file-write-date (function (pathname-designator) (or unsigned-byte null))
  add_ftype(Q("FILE-WRITE-DATE"),
    list(Q("PATHNAME-DESIGNATOR")),
    list(Q("OR"), Q("UNSIGNED-BYTE"), Qnull) );

  // pathname-match-p (function (pathname-designator pathname-designator) t)
  add_ftype(Q("PATHNAME-MATCH-P"),
    list(Q("PATHNAME-DESIGNATOR"), Q("PATHNAME-DESIGNATOR")),
    t );

  // values (function (&rest t) (values &rest t))
  add_ftype(Q("VALUES"),
    list(Q("&REST"), t),
    list(Q("VALUES"), Q("&REST"), t) );

  // dribble (function (&optional pathname-designator) t)
  add_ftype(Q("DRIBBLE"),
    list(Q("&OPTIONAL"), Q("PATHNAME-DESIGNATOR")),
    t );

  // ldb (function (bytespec integer) integer)
  add_ftype(Q("LDB"),
    list(Q("BYTESPEC"), Qinteger),
    Qinteger );

  // tanh (function (number) number)
  add_ftype(Q("TANH"),
    list(Qnumber),
    Qnumber );

  // intern (function (string &optional package-designator) (values symbol (member :inherited :external :internal nil)))
  add_ftype(Q("INTERN"),
    list(Qstring, Q("&OPTIONAL"), Q("PACKAGE-DESIGNATOR")),
    list(Q("VALUES"), Qsymbol, list(Q("MEMBER"), Q(":INHERITED"), Q(":EXTERNAL"), Q(":INTERNAL"), nil)) );

  // list-length (function (list) (or sequence-index null))
  add_ftype(Q("LIST-LENGTH"),
    list(Qlist),
    list(Q("OR"), Q("SEQUENCE-INDEX"), Qnull) );

  // write-char (function (character &optional (or stream (member nil t))) character)
  add_ftype(Q("WRITE-CHAR"),
    list(Qcharacter, Q("&OPTIONAL"), list(Q("OR"), Qstream, list(Q("MEMBER"), nil, t))),
    Qcharacter );

  // remove-method (function (generic-function method) generic-function)
  add_ftype(Q("REMOVE-METHOD"),
    list(Qgeneric_function, Qmethod),
    Qgeneric_function );

  // two-way-stream-output-stream (function (two-way-stream) stream)
  add_ftype(Q("TWO-WAY-STREAM-OUTPUT-STREAM"),
    list(Qtwo_way_stream),
    Qstream );

  // slot-boundp (function (t symbol) t)
  add_ftype(Q("SLOT-BOUNDP"),
    list(t, Qsymbol),
    t );

  // probe-file (function (pathname-designator) physical-pathname)
  add_ftype(Q("PROBE-FILE"),
    list(Q("PATHNAME-DESIGNATOR")),
    Qphysical_pathname );

  // copy-list (function (list) list)
  add_ftype(Q("COPY-LIST"),
    list(Qlist),
    Qlist );

  // plusp (function (real) t)
  add_ftype(Q("PLUSP"),
    list(Qreal),
    t );

  // read-byte (function (stream &optional t t) t)
  add_ftype(Q("READ-BYTE"),
    list(Qstream, Q("&OPTIONAL"), t, t),
    t );

  // not (function (t) t)
  add_ftype(Q("NOT"),
    list(t),
    t );

  // apropos-list (function (string &optional (or package-designator null)) list)
  add_ftype(Q("APROPOS-LIST"),
    list(Qstring, Q("&OPTIONAL"), list(Q("OR"), Q("PACKAGE-DESIGNATOR"), Qnull)),
    Qlist );

